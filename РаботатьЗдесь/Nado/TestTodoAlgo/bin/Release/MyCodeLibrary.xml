<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MyCodeLibrary</name>
    </assembly>
    <members>
        <member name="T:MyCodeLibrary.FlashWindow">
            <summary>
            RT-Класс мигает окном на панели задач
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FlashWindow.FLASHWINFO.cbSize">
            <summary>
            The size of the structure in bytes.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FlashWindow.FLASHWINFO.hwnd">
            <summary>
            A Handle to the Window to be Flashed. The window can be either opened or minimized.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FlashWindow.FLASHWINFO.dwFlags">
            <summary>
            The Flash Status.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FlashWindow.FLASHWINFO.uCount">
            <summary>
            The number of times to Flash the window.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FlashWindow.FLASHWINFO.dwTimeout">
            <summary>
            The rate at which the Window is to be flashed, in milliseconds. If Zero, the function uses the default cursor blink rate.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FlashWindow.FLASHW_STOP">
            <summary>
            Stop flashing. The system restores the window to its original stae.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FlashWindow.FLASHW_CAPTION">
            <summary>
            Flash the window caption.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FlashWindow.FLASHW_TRAY">
            <summary>
            Flash the taskbar button.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FlashWindow.FLASHW_ALL">
            <summary>
            Flash both the window caption and taskbar button.
            This is equivalent to setting the FLASHW_CAPTION | FLASHW_TRAY flags.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FlashWindow.FLASHW_TIMER">
            <summary>
            Flash continuously, until the FLASHW_STOP flag is set.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FlashWindow.FLASHW_TIMERNOFG">
            <summary>
            Flash continuously until the window comes to the foreground.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.FlashWindow.Win2000OrLater">
            <summary>
            A boolean value indicating whether the application is running on Windows 2000 or later.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.FlashWindow.Flash(System.Windows.Forms.Form)">
            <summary>
            Flash the spacified Window (Form) until it recieves focus.
            </summary>
            <param name="form">The Form (Window) to Flash.</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.FlashWindow.Flash(System.Windows.Forms.Form,System.UInt32)">
            <summary>
            Flash the specified Window (form) for the specified number of times
            </summary>
            <param name="form">The Form (Window) to Flash.</param>
            <param name="count">The number of times to Flash.</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.FlashWindow.Start(System.Windows.Forms.Form)">
            <summary>
            Start Flashing the specified Window (form)
            </summary>
            <param name="form">The Form (Window) to Flash.</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.FlashWindow.Stop(System.Windows.Forms.Form)">
            <summary>
            Stop Flashing the specified Window (form)
            </summary>
            <param name="form"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:MyCodeLibrary.PreventSleep" -->
        <member name="M:MyCodeLibrary.PreventSleep.PreventDisplayOff">
            <summary>
            NT-Предотвратить выключение дисплея по таймеру. И системы соответственно.
            </summary>
            <returns>Возвращает предыдущее состояние свойства.</returns>
            <remarks></remarks>
        </member>
        <member name="M:MyCodeLibrary.PreventSleep.PreventSystemOffWinXP">
            <summary>
            NT-Предотвратить засыпание компьютера при бездействии. 
            Монитор гасится по таймеру. Версия для Windows2000 и XP.
            </summary>
            <returns>Возвращает предыдущее состояние свойства.</returns>
        </member>
        <member name="M:MyCodeLibrary.PreventSleep.PreventSystemOffWinVista">
            <summary>
            NT-Предотвратить засыпание компьютера при бездействии. 
            Монитор гасится по таймеру. Версия для Windows Vista, не работает в WindowsXP.
            </summary>
            <returns>Возвращает предыдущее состояние свойства.</returns>
        </member>
        <member name="M:MyCodeLibrary.PreventSleep.ClearPrevents">
            <summary>
            NT-Отменить запрещения гасить монитор и усыплять систему.
            </summary>
            <returns>Возвращает предыдущее состояние свойства.</returns>
        </member>
        <member name="M:MyCodeLibrary.PreventSleep.KeepSystemAwake">
            <summary>
            NT-Периодически сбрасывать таймер усыпления системы
            </summary>
            <returns>Возвращает предыдущее состояние свойства.</returns>
        </member>
        <member name="M:MyCodeLibrary.PreventSleep.KeepDisplayAwake">
            <summary>
            NT-Периодически сбрасывать таймер выключения монитора
            </summary>
            <returns>Возвращает предыдущее состояние свойства.</returns>
        </member>
        <member name="T:MyCodeLibrary.PreventSleep.EXECUTION_STATE">
            <summary>
            Флаги состояния
            </summary>
        </member>
        <member name="F:MyCodeLibrary.PreventSleep.EXECUTION_STATE.ES_AWAYMODE_REQUIRED">
            <summary>
            Флаг состояния AWAYMODE - поддерживается начиная с Windows Vista
            </summary>
            <remarks>
            Although Away Mode is supported on any Windows Vista PC, the mode must be explicitly allowed by the current power policy. The Allow Away Mode power setting enables the user to selectively allow Away Mode on one or more power plans or individually for AC and DC (on battery) power states.
            (see more about this at http://msdn.microsoft.com/en-us/windows/hardware/gg463208.aspx )
            Description of what the different EXECUTION_STATE does - http://msdn.microsoft.com/en-us/library/aa373208(v=vs.85).aspx
            </remarks>
        </member>
        <member name="F:MyCodeLibrary.PreventSleep.EXECUTION_STATE.ES_CONTINUOUS">
            <summary>
            Informs the system that the state being set should remain in effect until the next call that uses ES_CONTINUOUS and one of the other state flags is cleared.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.PreventSleep.EXECUTION_STATE.ES_DISPLAY_REQUIRED">
            <summary>
            Сохранить Дисплей включенным
            </summary>
        </member>
        <member name="F:MyCodeLibrary.PreventSleep.EXECUTION_STATE.ES_SYSTEM_REQUIRED">
            <summary>
            Сохранить систему включенной
            </summary>
        </member>
        <member name="T:MyCodeLibrary.PreventSleepWin7">
            <summary>
            NT-Запретить засыпание компьютера, гашение дисплея и запуск скринсейвера для Windows 7 и более поздних ОС.
            </summary>
            <remarks>
            Не тестировался!!!
            </remarks>
        </member>
        <member name="M:MyCodeLibrary.PreventSleepWin7.EnableConstantDisplayAndPower(System.Boolean,System.String)">
            <summary>
            Prevent screensaver, display dimming and power saving. This function wraps PInvokes on Win32 API. 
            </summary>
            <param name="enableConstantDisplayAndPower">True to get a constant display and power - False to clear the settings</param>
            <param name="reasonString">your reason for changing the power settings;</param>
        </member>
        <member name="T:MyCodeLibrary.AssemblyInfo">
            <summary>
            NT-Объект свойств сборки и различные операции со сборками.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.AssemblyInfo.m_Version">
            <summary>
            Specifies the version of the assembly being attributed.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.AssemblyInfo.m_FileVersion">
            <summary>
            Instructs a compiler to use a specific version number for the Win32 file version resource. 
            The Win32 file version is not required to be the same as the assembly's version number.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.AssemblyInfo.m_Title">
            <summary>
            Defines an assembly title custom attribute for an assembly manifest.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.AssemblyInfo.m_Description">
            <summary>
            Provides a text description for an assembly.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.AssemblyInfo.m_Product">
            <summary>
            Defines a product name custom attribute for an assembly manifest.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.AssemblyInfo.m_Copyright">
            <summary>
            Defines a copyright custom attribute for an assembly manifest.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.AssemblyInfo.m_Company">
            <summary>
            Defines a company name
            </summary>
        </member>
        <member name="F:MyCodeLibrary.AssemblyInfo.m_Culture">
            <summary>
            Specifies which culture the assembly supports.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfo.#ctor">
            <summary>
            NT-Default constructor
            </summary>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfo.#ctor(System.Reflection.Assembly)">
            <summary>
            NT-Constructor
            </summary>
            <param name="a">Assembly</param>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfo.#ctor(System.String)">
            <summary>
            NT-Constructor
            </summary>
            <param name="path">Assembly file path</param>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfo.getAssembly">
            <summary>
            NT-Get calling assembly
            </summary>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfo.getAssembly(System.String)">
            <summary>
            NT- get assembly by file path
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfo.getEntryAssembly">
            <summary>
            NT- get assembly of exe file
            </summary>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfo.getVersionString(System.Reflection.Assembly)">
            <summary>
            NT-Returns the version number
            </summary>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfo.getVersion(System.Reflection.Assembly)">
            <summary>
            NT-Returns the version number 
            </summary>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfo.getTitle(System.Reflection.Assembly)">
            <summary>
            NT-Returns the title of the assembly.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfo.getDescription(System.Reflection.Assembly)">
            <summary>
            NT-Returns the description  of the assembly.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfo.getProduct(System.Reflection.Assembly)">
            <summary>
            NT-Returns the product name  of the assembly.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfo.getCopyright(System.Reflection.Assembly)">
            <summary>
            NT-Returns the copyright info  of the assembly.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfo.getCompany(System.Reflection.Assembly)">
            <summary>
            NT-Returns the company name  of the assembly.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfo.getFileVersion(System.Reflection.Assembly)">
            <summary>
            NT-Get Win32 file version string
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfo.getCulture(System.Reflection.Assembly)">
            <summary>
            NT-Get assembly attribute string
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfo.getApplicationIcon(System.String,System.Boolean)">
            <summary>
            NT-Извлечь иконку приложения из файла приложения
            </summary>
            <param name="appPath">Путь к файлу .exe  или .dll</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfo.SaveResourceToDisk(System.Reflection.Assembly,System.String,System.String)">
            <summary>
            NT-Extract Embedded resource from assembly manifest
            </summary>
            <param name="resourceName"></param>
            <param name="fileToExtractTo"></param>
        </member>
        <member name="T:MyCodeLibrary.AssemblyInfoEx">
            <summary>
            NT-Объект подробных свойств сборки и унаследованные операции со сборками.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.AssemblyInfoEx.m_Configuration">
            <summary>
            Specifies the build configuration, such as retail or debug, for an assembly.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.AssemblyInfoEx.m_Trademark">
            <summary>
            Defines a trademark custom attribute for an assembly manifest.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.AssemblyInfoEx.m_ComVisible">
            <summary>
            Controls accessibility of an individual managed type or member, or of all types within an assembly, to COM.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.AssemblyInfoEx.m_Guid">
            <summary>
            Supplies an explicit System.Guid when an automatic GUID is undesirable.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.AssemblyInfoEx.m_AlgoritmId">
            <summary>
            Specifies an algorithm to hash all files in an assembly.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.AssemblyInfoEx.m_DefaultAlias">
            <summary>
            Defines a friendly default alias for an assembly manifest.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.AssemblyInfoEx.m_DelaySign">
            <summary>
            Specifies that the assembly is not fully signed when created.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.AssemblyInfoEx.m_Flags">
            <summary>
            Specifies a bitwise combination of AssemblyNameFlags flags for an assembly, 
            describing just-in-time (JIT) compiler options, whether the assembly is retargetable, 
            and whether it has a full or tokenized public key. 
            </summary>
        </member>
        <member name="F:MyCodeLibrary.AssemblyInfoEx.m_InformationalVersion">
            <summary>
            Defines additional version information for an assembly manifest.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.AssemblyInfoEx.m_KeyFile">
            <summary>
            Specifies the name of a file containing the key pair used to generate a strong name.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.AssemblyInfoEx.m_KeyName">
            <summary>
            Specifies the name of a key container within the CSP containing the key pair used to generate a strong name.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfoEx.#ctor">
            <summary>
            NT-Default constructor
            </summary>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfoEx.#ctor(System.Reflection.Assembly)">
            <summary>
            NT-Constructor
            </summary>
            <param name="a">Assembly</param>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfoEx.#ctor(System.String)">
            <summary>
            NT-Constructor
            </summary>
            <param name="path">Assembly file path</param>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfoEx.getGuid(System.Reflection.Assembly)">
            <summary>
            NT-Get assembly Guid string
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfoEx.getComVisible(System.Reflection.Assembly)">
            <summary>
            NT-Get assembly attribute. 
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfoEx.getTrademark(System.Reflection.Assembly)">
            <summary>
            NT-Get assembly attribute string
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfoEx.getConfiguration(System.Reflection.Assembly)">
            <summary>
            NT-Get assembly attribute string
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfoEx.getKeyName(System.Reflection.Assembly)">
            <summary>
            NT-Get assembly attribute string
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfoEx.getKeyFile(System.Reflection.Assembly)">
            <summary>
            NT-Get assembly attribute string
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfoEx.getInformationalVersion(System.Reflection.Assembly)">
            <summary>
            NT-Get assembly attribute string
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfoEx.getFlags(System.Reflection.Assembly)">
            <summary>
            NT-Get assembly attribute string
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfoEx.getDelaySign(System.Reflection.Assembly)">
            <summary>
            NT-Get assembly attribute string
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfoEx.getDefaultAlias(System.Reflection.Assembly)">
            <summary>
            NT-Get assembly attribute string
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.AssemblyInfoEx.getAlgoritmId(System.Reflection.Assembly)">
            <summary>
            NT-Get assembly attribute string
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:MyCodeLibrary.Cache`2" -->
        <member name="F:MyCodeLibrary.Cache`2._capacity">
            <summary>
            Максимальное число элементов, хранящихся  в кеше
            </summary>
        </member>
        <member name="F:MyCodeLibrary.Cache`2._keyQ">
            <summary>
            Очередь ключей
            </summary>
        </member>
        <member name="F:MyCodeLibrary.Cache`2._contents">
            <summary>
            Основное хранилище данных
            </summary>
        </member>
        <member name="M:MyCodeLibrary.Cache`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="initialCapacity">Начальная емкость коллекции</param>
            <param name="capacity">Предельная емкость коллекции. Если указать 0, емкость коллекции не ограничена.</param>
        </member>
        <member name="P:MyCodeLibrary.Cache`2.Item(`0)">
            <summary>
            Енумератор[key]
            </summary>
            <param name="key">Значение ключа</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.Cache`2.Add(`0,`1)">
            <summary>
            Добавить ключ и значение в коллекцию
            </summary>
            <param name="key">Ключ</param>
            <param name="value">Значение</param>
        </member>
        <member name="M:MyCodeLibrary.Cache`2.InternalAdd(`0,`1)">
            <summary>
            Добавить ключ и значение в коллекцию
            </summary>
            <param name="key">Ключ</param>
            <param name="value">Значение</param>
        </member>
        <member name="T:MyCodeLibrary.FolderExistsCache">
            <summary>
            Класс кеширует функцию проверки существования каталога с указанным путем.
            Применять только для проверки наличия каталога, 
            когда он только может создаваться, но не удаляться в процессе существования объекта класса.
            </summary>
            <remarks>
            Это небольшая оптимизация для случая, когда надо создавать много подкаталогов и файлов в них.
            Повышает скорость за счет расхода памяти. 
            </remarks>
        </member>
        <member name="F:MyCodeLibrary.FolderExistsCache.m_dict">
            <summary>
            Словарь путей каталогов
            </summary>
        </member>
        <member name="M:MyCodeLibrary.FolderExistsCache.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MyCodeLibrary.FolderExistsCache.isFolderExists(System.String)">
            <summary>
            RT-Проверить существование каталога
            </summary>
            <param name="folderPath">Путь к каталогу</param>
            <returns>Возвращает True или False</returns>
        </member>
        <member name="M:MyCodeLibrary.FolderExistsCache.CreateIfNotExists(System.String)">
            <summary>
            RT-Создать каталог если он не существует
            </summary>
            <param name="folderPath">Путь к каталогу</param>
        </member>
        <member name="T:MyCodeLibrary.StringIntCache">
            <summary>
            Кэш строк по инт32 уникальным идентификаторам
            </summary>
            <remarks>
            Это словарь-кеш строк по Int32 ключам. Когда число элементов превышает установленный предел, весь словарь очищается и может заполняться заново.
            Это ускоряет работу программы. Но надо выбирать размер кеша так, чтобы он был достаточно большим - примерно 10..25 процентов от числа уникальных объектов.
            Данный словарь использовался в начале функции выборки имени пользователя сайта из БД, поэтому он сильно ускорил работу.
            </remarks>
        </member>
        <member name="F:MyCodeLibrary.StringIntCache.m_CacheMaxSize">
            <summary>
            Максимальный размер кеша
            </summary>
        </member>
        <member name="F:MyCodeLibrary.StringIntCache.m_userLinkDictionary">
            <summary>
            Словарь элементов кеша
            </summary>
        </member>
        <member name="M:MyCodeLibrary.StringIntCache.#ctor">
            <summary>
            NT-Конструктор. Максимальное число элементов кеша = 1000.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.StringIntCache.#ctor(System.Int32)">
            <summary>
            NT-Конструктор
            </summary>
            <param name="maxSize">Максимальное число элементов кеша</param>
        </member>
        <member name="P:MyCodeLibrary.StringIntCache.Count">
            <summary>
            Получить текущее количество элементов в кеше
            </summary>
        </member>
        <member name="P:MyCodeLibrary.StringIntCache.Size">
            <summary>
            Получить или установить максимальный размер (емкость) кеша, после которой кеш будет очищен.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.StringIntCache.Add(System.Int32,System.String)">
            <summary>
            NT-Добавить элемент в кеш
            </summary>
            <param name="Id">Уникальный идентификатор элемента</param>
            <param name="item">Добавляемый элемент кеша</param>
        </member>
        <member name="M:MyCodeLibrary.StringIntCache.Get(System.Int32)">
            <summary>
            NT-Получить элемент кеша по его идентификатору
            </summary>
            <param name="Id">Уникальный идентификатор элемента</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.StringIntCache.IsExists(System.Int32)">
            <summary>
            NT-Проверить существование в кеше элемента по идентификатору
            </summary>
            <param name="Id">Уникальный идентификатор элемента</param>
            <returns></returns>
        </member>
        <member name="T:MyCodeLibrary.CardFile.CardFileSection">
            <summary>
            Секция файла карточки
            </summary>
        </member>
        <member name="F:MyCodeLibrary.CardFile.CardFileSection.m_Title">
            <summary>
            Строка названия раздела карточки
            </summary>
        </member>
        <member name="F:MyCodeLibrary.CardFile.CardFileSection.m_Data">
            <summary>
            Блок байт содержимого раздела карточки
            </summary>
        </member>
        <member name="F:MyCodeLibrary.CardFile.CardFileSection.SectionStartTag">
            <summary>
            Код тега заголовка секции
            </summary>
        </member>
        <member name="F:MyCodeLibrary.CardFile.CardFileSection.FileEndTag">
            <summary>
            Код тега конца файла секций
            </summary>
        </member>
        <member name="M:MyCodeLibrary.CardFile.CardFileSection.#ctor">
            <summary>
            Конструктор
            </summary>
        </member>
        <member name="M:MyCodeLibrary.CardFile.CardFileSection.#ctor(System.String,System.Byte[])">
            <summary>
            NT-Конструктор с параметрами
            </summary>
            <param name="НазваниеРаздела"></param>
            <param name="БлокДанныхРаздела"></param>
        </member>
        <member name="P:MyCodeLibrary.CardFile.CardFileSection.Title">
            <summary>
            Название секции файла карточки
            </summary>
        </member>
        <member name="P:MyCodeLibrary.CardFile.CardFileSection.Data">
            <summary>
            Название секции файла карточки
            </summary>
        </member>
        <member name="M:MyCodeLibrary.CardFile.CardFileSection.ToString">
            <summary>
            NT-Получить строковое представление объекта
            </summary>
            <returns></returns>
        </member>
        <member name="T:MyCodeLibrary.CardFile.ElementCard">
            <summary>
            Класс карточки абстрактного  Элемента Инвентарь
            </summary>
        </member>
        <member name="F:MyCodeLibrary.CardFile.ElementCard.CardFileSignature">
            <summary>
            Заголовок файла
            </summary>
        </member>
        <member name="F:MyCodeLibrary.CardFile.ElementCard.CardFileFormatVersion">
            <summary>
            Код версии формата файла
            </summary>
        </member>
        <member name="F:MyCodeLibrary.CardFile.ElementCard.m_ChapterDictionary">
            <summary>
            Словарь разделов карточки
            </summary>
        </member>
        <member name="F:MyCodeLibrary.CardFile.ElementCard.m_FilePath">
            <summary>
            Путь к файлу карточки
            </summary>
        </member>
        <member name="F:MyCodeLibrary.CardFile.ElementCard.m_fileid">
            <summary>
            Тут хранится идентификатор файла для индивидуального ключа файла.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.CardFile.ElementCard.m_keyManager">
            <summary>
            Менеджер ключей
            </summary>
        </member>
        <member name="F:MyCodeLibrary.CardFile.ElementCard.m_ContentHash">
            <summary>
            Хеш содержимого файла для сравнения версий
            </summary>
        </member>
        <member name="F:MyCodeLibrary.CardFile.ElementCard.m_WriteTime">
            <summary>
            Таймштамп момента записи в файл
            </summary>
        </member>
        <member name="F:MyCodeLibrary.CardFile.ElementCard.m_CreateTime">
            <summary>
            Таймштамп момента создания файла
            </summary>
        </member>
        <member name="M:MyCodeLibrary.CardFile.ElementCard.#ctor">
            <summary>
            Конструктор
            </summary>
        </member>
        <member name="M:MyCodeLibrary.CardFile.ElementCard.Finalize">
            <summary>
            Деструктор
            </summary>
        </member>
        <member name="P:MyCodeLibrary.CardFile.ElementCard.ContentHash">
            <summary>
            Получить хеш содержимого файла для сравнения версий
            </summary>
        </member>
        <member name="P:MyCodeLibrary.CardFile.ElementCard.WriteTime">
            <summary>
            Получить таймштамп момента записи в файл
            </summary>
        </member>
        <member name="P:MyCodeLibrary.CardFile.ElementCard.CreateTime">
            <summary>
            Таймштамп момента создания файла
            </summary>
        </member>
        <member name="P:MyCodeLibrary.CardFile.ElementCard.FileId">
            <summary>
            Уникальный идентификатор файла для индивидуального ключа файла.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.CardFile.ElementCard.KeyManager">
            <summary>
            Менеджер ключей
            </summary>
        </member>
        <member name="P:MyCodeLibrary.CardFile.ElementCard.FilePath">
            <summary>
            Путь к файлу элемента
            </summary>
        </member>
        <member name="M:MyCodeLibrary.CardFile.ElementCard.IsNewElement">
            <summary>
            NT-Возвращает труе если это новый элемент, не записанный в хранилише
            Проверяются значения: FileId = 0 или FilePath = null
            </summary>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CardFile.ElementCard.createFileName">
            <summary>
            NR-Создать имя для нового файла.
            Эта операция должна быть реализована в производных классах.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CardFile.ElementCard.GetFileId(System.String)">
            <summary>
            NR-Извлечь идентификатор файла
            </summary>
            <param name="filepath">Путь к файлу</param>
            <returns>Возвращает идентификатор файла</returns>
        </member>
        <member name="M:MyCodeLibrary.CardFile.ElementCard.LoadCard(System.String)">
            <summary>
            NR-Загрузить карточку из файла
            </summary>
            <param name="cardFilePath">Путь к файлу карточки</param>
        </member>
        <member name="M:MyCodeLibrary.CardFile.ElementCard.SaveCard">
            <summary>
            NT-Сохранить карточку в тот же файл
            </summary>
        </member>
        <member name="M:MyCodeLibrary.CardFile.ElementCard.SaveCard(System.String)">
            <summary>
            NR-Сохранить карточку в другой файл. Ноавый путь не становится текущим для карточки
            </summary>
        </member>
        <member name="M:MyCodeLibrary.CardFile.ElementCard.GetChapter(System.String)">
            <summary>
            NT-Получить данные раздела. Возвращает null если нет такого раздела.
            </summary>
            <param name="НазваниеРаздела">Название раздела</param>
        </member>
        <member name="M:MyCodeLibrary.CardFile.ElementCard.GetChapterAsText(System.String)">
            <summary>
            NT-Получить данные раздела. Возвращает null если нет такого раздела.
            </summary>
            <param name="НазваниеРаздела">Название раздела</param>
        </member>
        <member name="M:MyCodeLibrary.CardFile.ElementCard.GetChapterAsImage(System.String)">
            <summary>
            NT-Получить данные раздела. Возвращает null если нет такого раздела.
            </summary>
            <param name="НазваниеРаздела">Название раздела</param>
        </member>
        <member name="M:MyCodeLibrary.CardFile.ElementCard.WriteChapter(System.String,System.Byte[])">
            <summary>
            NT-Перезаписать данные раздела или добавить новый раздел
            </summary>
            <param name="НазваниеРаздела">Название раздела</param>
            <param name="БлокДанныхРаздела">Блок данных раздела</param>
        </member>
        <member name="M:MyCodeLibrary.CardFile.ElementCard.WriteChapterAsText(System.String,System.String)">
            <summary>
            NT-Перезаписать данные раздела или добавить новый раздел
            </summary>
            <param name="НазваниеРаздела">Название раздела</param>
            <param name="ТекстРаздела">Текст раздела</param>
        </member>
        <member name="M:MyCodeLibrary.CardFile.ElementCard.WriteChapterAsImage(System.String,System.Drawing.Image)">
            <summary>
            NT-Перезаписать данные раздела или добавить новый раздел
            </summary>
            <param name="НазваниеРаздела">Название раздела</param>
            <param name="Изображение">Изображение</param>
        </member>
        <member name="M:MyCodeLibrary.CardFile.ElementCard.RemoveChapter(System.String)">
            <summary>
            NT-Удалить раздел
            </summary>
            <param name="НазваниеРаздела">Название раздела</param>
        </member>
        <member name="T:MyCodeLibrary.CardFile.KeyManager">
            <summary>
            TODO: Незаконченный класс менеджера паролей приложения
            </summary>
        </member>
        <member name="M:MyCodeLibrary.CardFile.KeyManager.ClearBlock(System.Byte[])">
            <summary>
            Заполнить массив нулями
            </summary>
            <param name="data">Массив для обработки</param>
        </member>
        <member name="M:MyCodeLibrary.CardFile.KeyManager.EncodeDecode(System.Byte[],System.Byte[])">
            <summary>
            Кодировать или декодировать блок данных по ранее созданному ключу
            </summary>
            <param name="data">Блок данных для обработки</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CardFile.KeyManager.CreateMasterKey(System.String,System.String)">
            <summary>
            NR-Создать первичный ключ из паролей пользователя
            </summary>
            <param name="userPass">Короткий пароль пользователя</param>
            <param name="appPass">Длинный пароль приложения</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CardFile.KeyManager.StoreFile(System.String,System.Byte[])">
            <summary>
            NT-Вывести массив байт в файл для оценки энтропии
            </summary>
            <param name="p"></param>
            <param name="bytes"></param>
        </member>
        <member name="M:MyCodeLibrary.CardFile.KeyManager.CreateFileKey(System.UInt32)">
            <summary>
            NR-Сгенерировать ключ файла по номеру файла.
            </summary>
            <param name="FileNumber">Номер файла</param>
        </member>
        <member name="M:MyCodeLibrary.CardFile.KeyManager.CodeFile(System.UInt32,System.Byte[])">
            <summary>
            Зашифровать или дешифровать блок данных файла
            </summary>
            <param name="FileNumber">Номер из файла</param>
            <param name="data">Блок данных файла</param>
            <returns>Возвращает преобразованный блок данных</returns>
        </member>
        <member name="T:MyCodeLibrary.CardFile.SimpleKeyManager">
            <summary>
            простой шифоровальщик - ничего не шифрует
            </summary>
        </member>
        <member name="M:MyCodeLibrary.CardFile.SimpleKeyManager.CodeFile(System.UInt32,System.Byte[])">
            <summary>
            Зашифровать или дешифровать блок данных файла
            </summary>
            <param name="FileNumber">Номер из файла</param>
            <param name="data">Блок данных файла</param>
            <returns>Возвращает преобразованный блок данных</returns>
        </member>
        <member name="M:MyCodeLibrary.CExceptionProcessor.ExceptionIfNull(System.Object,System.String,System.String)">
            <summary>
            Throws an <see cref="T:System.ArgumentNullException"/>
            if the the value is null
            </summary>
            <param name="input">The value to test.</param>
            <param name="message">The message to display if the value is null.</param>
            <param name="name">The name of the parameter being tested.</param>
        </member>
        <member name="M:MyCodeLibrary.CExceptionProcessor.ExceptionIfNullOrEmpty(System.Collections.ICollection,System.String,System.String)">
            <summary>
            Throws an <see cref="T:System.ArgumentNullException"/>
            if the the Collection is null or empty
            </summary>
            <param name="input">The value to test.</param>
            <param name="message">The message to display if the value is null.</param>
            <param name="name">The name of the parameter being tested.</param>
        </member>
        <member name="M:MyCodeLibrary.CExceptionProcessor.ExceptionIfNullOrEmpty(System.Collections.IDictionary,System.String,System.String)">
            <summary>
            Throws an <see cref="T:System.ArgumentNullException"/>
            if the the Dictionary is null or empty
            </summary>
            <param name="input">The value to test.</param>
            <param name="message">The message to display if the value is null.</param>
            <param name="name">The name of the parameter being tested.</param>
        </member>
        <member name="M:MyCodeLibrary.CExceptionProcessor.ExceptionIfNullOrEmpty(System.Collections.IList,System.String,System.String)">
            <summary>
            Throws an <see cref="T:System.ArgumentNullException"/>
            if the the List is null or empty
            </summary>
            <param name="input">The value to test.</param>
            <param name="message">The message to display if the value is null.</param>
            <param name="name">The name of the parameter being tested.</param>
        </member>
        <member name="M:MyCodeLibrary.CExceptionProcessor.ExceptionIfNullOrEmpty(System.String,System.String,System.String)">
            <summary>
            Throws an <see cref="T:System.ArgumentException"/> if the string value is null or empty.
            </summary>
            <param name="input">The value to test.</param>
            <param name="message">The message to display if the value is null.</param>
            <param name="name">The name of the parameter being tested.</param>
        </member>
        <member name="M:MyCodeLibrary.CImageProcessor.ImageToBytes(System.Drawing.Image)">
            <summary>
            RT-Конвертировать картинку в блок данных
            </summary>
            <param name="img">Конвертируемое изображение</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CImageProcessor.BytesToImage(System.Byte[])">
            <summary>
            RT-Конвертировать блок данных в картинку. Возвращает изображение или null
            </summary>
            <param name="bar">Конвертируемый блок данных</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CImageProcessor.CreateGrayscaleImage(System.Drawing.Image)">
            <summary>
            RT-Создать серо-белую (неактивную) иконку из цветной иконки категории
            </summary>
            <param name="img"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CImageProcessor.GetMD5Hash(System.Drawing.Image)">
            <summary>
            RT-Получить хеш иконки
            </summary>
            <param name="icon">Картинка иконки</param>
            <returns>строка хеша иконки</returns>
        </member>
        <member name="M:MyCodeLibrary.CImageProcessor.ResizeImage(System.Drawing.Image,System.Drawing.Size)">
            <summary>
            RT-resize image with preserve aspect ratio
            </summary>
            <param name="image"></param>
            <param name="pictureSize"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CImageProcessor.GetScreenShot(System.Windows.Forms.Screen)">
            <summary>
            RT-Сделать скриншот экрана
            </summary>
            <param name="screen">Экран (дисплей)(если их в системе несколько)</param>
            <returns></returns>
            <example>
            Bitmap b = GetScreenShot(Screen.PrimaryScreen);
            b.Save(@"c:\my_screenshot.jpg", ImageFormat.Jpeg);
            </example>
        </member>
        <member name="T:MyCodeLibrary.CNativeMethodProcessor">
            <summary>
            NT- нативные функции сообрать здесь из всей библиотеки
            </summary>
        </member>
        <member name="T:MyCodeLibrary.CNetworkProcessor">
            <summary>
            Network information
            </summary>
        </member>
        <member name="P:MyCodeLibrary.CNetworkProcessor.InternalIPAddress">
            <summary>
            Returns the Internal IP Address.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.CNetworkProcessor.ExternalIPAddress(System.String@)">
            <summary>
            Returns the External IP Address by connecting to "http://api.ipify.org".
            </summary>
            <param name="error"></param>
            <returns></returns>
        </member>
        <member name="P:MyCodeLibrary.CNetworkProcessor.ConnectionStatus">
            <summary>
            Returns status of internet connection
            </summary>
        </member>
        <member name="M:MyCodeLibrary.CNumberProcessor.BytesToKB(System.Double)">
            <summary>
            Converts bytes to Kilobytes
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CNumberProcessor.BytesToMB(System.Double)">
            <summary>
            Converts bytes to Megabytes
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CNumberProcessor.BytesToGB(System.Double)">
            <summary>
            Converts bytes to Gigabytes
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CNumberProcessor.BytesToTB(System.Double)">
            <summary>
            Converts bytes to Terabytes
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CNumberProcessor.ConvertBytes(System.Double)">
            <summary>
            Returns the conversion from bytes to the correct version. Ex. 1024 bytes = 1 KB
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CNumberProcessor.ConvertKilobytes(System.Double)">
            <summary>
            Returns the conversion from KB to the correct version. Ex. 1024 KB = 1 MB
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CNumberProcessor.ToInt``1(``0)">
            <summary>
            Converts any type to an int
            </summary>
            <typeparam name="T">Any object</typeparam>
            <param name="input">Value to convert</param>
            <returns>The integer, 0 if unsuccessful</returns>
        </member>
        <member name="M:MyCodeLibrary.CNumberProcessor.ToInt``1(``0,System.Int32)">
            <summary>
            Converts any type to an int. Returns defaultValue if fails
            </summary>
            <param name="input">Value to convert</param>
            <typeparam name="T">Any object</typeparam>
            <param name="defaultValue">Default to use</param>
            <returns>The defaultValue if unsuccessful</returns>
        </member>
        <member name="M:MyCodeLibrary.CNumberProcessor.IsInt(System.String)">
            <summary>
            Checks to see if a string is an int
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CNumberProcessor.ToInt(System.String,System.Int32)">
            <summary>
            Converts a string to an int. Returns defaultValue if fails
            </summary>
            <param name="input"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CNumberProcessor.IsDecimal(System.String)">
            <summary>
            Checks to see if a string is a Decimal
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CNumberProcessor.ToDecimal(System.String,System.Decimal)">
            <summary>
            Converts a string to a double. Returns defaultValue if fails
            </summary>
            <param name="input"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CNumberProcessor.ToDouble(System.String)">
            <summary>
            Converts a string to a double
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CNumberProcessor.IsPrime(System.Int32)">
            <summary>
            Checks if a number is prime
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CNumberProcessor.IsEven(System.Int32)">
            <summary>
            Checks if a number is even
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CNumberProcessor.IsOdd(System.Int32)">
            <summary>
            Checks if a number is odd
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CNumberProcessor.Squared(System.Int32)">
            <summary>
            Returns a number squared
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CNumberProcessor.IsInRange(System.Int32,System.Int32,System.Int32)">
            <summary>
            Checks if a number is in between a range
            </summary>
            <param name="input"></param>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CNumberProcessor.RoundDecimalPoints(System.Decimal,System.Int32)">
            <summary>
            Rounds the supplied decimal to the specified amount of decimal points
            </summary>
            <param name="input">The decimal to round</param>
            <param name="decimalPoints">The number of decimal points to round the output value to</param>
            <returns>A rounded decimal</returns>
        </member>
        <member name="M:MyCodeLibrary.CNumberProcessor.RoundToTwoDecimalPoints(System.Decimal)">
            <summary>
            Rounds the supplied decimal value to two decimal points
            </summary>
            <param name="input">The decimal to round</param>
            <returns>A decimal value rounded to two decimal points</returns>
        </member>
        <member name="M:MyCodeLibrary.Collections.CollectionsUtility.SplitListInt32(System.Collections.Generic.List{System.Int32},System.Int32)">
            <summary>
            RT-разделить список на части по N элементов или менее
            </summary>
            <remarks>
            Применялся для построения запроса SQL, чтобы запрашивать из большой СУБД сразу 5..10 записей за раз.
            Для БД на миллион записей - большая экономия времени.
            </remarks>
            <param name="idList">Исходный список</param>
            <param name="n">Размер каждой из частей, больше 0</param>
            <returns>Возвращает список списков, каждый из которых содержит части входного списка.</returns>
        </member>
        <member name="M:MyCodeLibrary.Collections.CollectionsUtility.BreakDictionaryToString(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Breaks a dictionary into a string value
            </summary>
            <param name="dictionary"></param>
            <returns></returns>
        </member>
        <member name="T:MyCodeLibrary.Collections.UnicalFilesCollection">
            <summary>
            Коллекция, в которой нет одинаковых файлов. Дубликаты не добавляются в коллекцию.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.Collections.UnicalFilesCollection.AddFile(System.String)">
            <summary>
            NT-add new file to collection
            </summary>
            <param name="filepath"></param>
        </member>
        <member name="M:MyCodeLibrary.Collections.UnicalFilesCollection.getUnicalFileCount">
            <summary>
            NT-
            </summary>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.Collections.UnicalFilesCollection.getUnicalFiles">
            <summary>
            NT-
            </summary>
            <returns></returns>
        </member>
        <member name="T:MyCodeLibrary.Collections.UnicalFileInfo">
            <summary>
            Информация о уникальном файле коллекции
            </summary>
        </member>
        <member name="M:MyCodeLibrary.Collections.UnicalFileInfo.IsEqualContent(System.String)">
            <summary>
            NT- сравнить файлы по содержимому
            </summary>
            <param name="anotherFilePath"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.Collections.UnicalFileInfo.isEqual(MyCodeLibrary.Collections.UnicalFileInfo)">
            <summary>
            NT-Проверить что записи тождественны
            </summary>
            <param name="ufi"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.Collections.UnicalFileInfo.#ctor(System.String)">
            <summary>
            NT- Конструктор
            </summary>
            <param name="filepath"></param>
        </member>
        <member name="M:MyCodeLibrary.Collections.UnicalFileInfo.calculateHash(System.String)">
            <summary>
            Вычислить MD5 хэш файла
            </summary>
            <param name="filepath">путь к файлу</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.Collections.UnicalFileInfo.CompareStreams(System.IO.Stream,System.IO.Stream)">
            <summary>
            NT-Проверить что содержимое потоков одинаковое
            </summary>
            <param name="zs">Поток 1</param>
            <param name="fs">Поток 2</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:MyCodeLibrary.Collections.VariablesCollection" -->
        <member name="F:MyCodeLibrary.Collections.VariablesCollection.m_Dictionary">
            <summary>
            Словарь для хранения переменных
            </summary>
        </member>
        <member name="F:MyCodeLibrary.Collections.VariablesCollection.m_Culture">
            <summary>
            Кэш информации о культуре, только для чтения.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.Collections.VariablesCollection.#ctor">
            <summary>
            RT-Конструктор
            </summary>
        </member>
        <member name="P:MyCodeLibrary.Collections.VariablesCollection.Culture">
            <summary>
            Получить кэш информации о культуре, только для чтения.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.Collections.VariablesCollection.Load(System.String)">
            <summary>
            RT-Загрузить данные из файла
            </summary>
            <param name="filename">Путь ХМЛ-файла с данными</param>
        </member>
        <member name="M:MyCodeLibrary.Collections.VariablesCollection.Save(System.String)">
            <summary>
            RT-Сохранить данные в файл
            </summary>
            <param name="filename">Путь ХМЛ-файла с данными, будет перезаписан</param>
        </member>
        <member name="M:MyCodeLibrary.Collections.VariablesCollection.Set(System.String,System.String)">
            <summary>
            RT-Создать или изменить переменную
            </summary>
            <param name="keyname">Название переменной</param>
            <param name="val">Новое значение переменной</param>
        </member>
        <member name="M:MyCodeLibrary.Collections.VariablesCollection.Set(System.String,System.Int32)">
            <summary>
            RT-Создать или изменить переменную
            </summary>
            <param name="keyname">Название переменной</param>
            <param name="val">Новое значение переменной</param>
        </member>
        <member name="M:MyCodeLibrary.Collections.VariablesCollection.Set(System.String,System.Int64)">
            <summary>
            RT-Создать или изменить переменную
            </summary>
            <param name="keyname">Название переменной</param>
            <param name="val">Новое значение переменной</param>
        </member>
        <member name="M:MyCodeLibrary.Collections.VariablesCollection.Set(System.String,System.Double)">
            <summary>
            RT-Создать или изменить переменную
            </summary>
            <param name="keyname">Название переменной</param>
            <param name="val">Новое значение переменной</param>
        </member>
        <member name="M:MyCodeLibrary.Collections.VariablesCollection.Set(System.String,System.Single)">
            <summary>
            RT-Создать или изменить переменную
            </summary>
            <param name="keyname">Название переменной</param>
            <param name="val">Новое значение переменной</param>
        </member>
        <member name="M:MyCodeLibrary.Collections.VariablesCollection.Set(System.String,System.DateTime)">
            <summary>
            RT-Создать или изменить переменную
            </summary>
            <param name="keyname">Название переменной</param>
            <param name="val">Новое значение переменной</param>
        </member>
        <member name="M:MyCodeLibrary.Collections.VariablesCollection.Set(System.String,System.TimeSpan)">
            <summary>
            RT-Создать или изменить переменную
            </summary>
            <param name="keyname">Название переменной</param>
            <param name="val">Новое значение переменной</param>
        </member>
        <member name="M:MyCodeLibrary.Collections.VariablesCollection.Set(System.String,System.Boolean)">
            <summary>
            RT-Создать или изменить переменную
            </summary>
            <param name="keyname">Название переменной</param>
            <param name="val">Новое значение переменной</param>
        </member>
        <member name="M:MyCodeLibrary.Collections.VariablesCollection.Get(System.String)">
            <summary>
            RT-Получить значение переменной
            </summary>
            <param name="keyname">Название переменной</param>
        </member>
        <member name="M:MyCodeLibrary.Collections.VariablesCollection.GetAsBoolean(System.String)">
            <summary>
            RT-Получить значение переменной
            </summary>
            <param name="keyname">Название переменной</param>
        </member>
        <member name="M:MyCodeLibrary.Collections.VariablesCollection.GetAsInt32(System.String)">
            <summary>
            RT-Получить значение переменной
            </summary>
            <param name="keyname">Название переменной</param>
        </member>
        <member name="M:MyCodeLibrary.Collections.VariablesCollection.GetAsInt64(System.String)">
            <summary>
            RT-Получить значение переменной
            </summary>
            <param name="keyname">Название переменной</param>
        </member>
        <member name="M:MyCodeLibrary.Collections.VariablesCollection.GetAsDouble(System.String)">
            <summary>
            RT-Получить значение переменной
            </summary>
            <param name="keyname">Название переменной</param>
        </member>
        <member name="M:MyCodeLibrary.Collections.VariablesCollection.GetAsSingle(System.String)">
            <summary>
            RT-Получить значение переменной
            </summary>
            <param name="keyname">Название переменной</param>
        </member>
        <member name="M:MyCodeLibrary.Collections.VariablesCollection.GetAsDateTime(System.String)">
            <summary>
            RT-Получить значение переменной
            </summary>
            <param name="keyname">Название переменной</param>
        </member>
        <member name="M:MyCodeLibrary.Collections.VariablesCollection.GetAsTimeSpan(System.String)">
            <summary>
            RT-Получить значение переменной
            </summary>
            <param name="keyname">Название переменной</param>
        </member>
        <member name="M:MyCodeLibrary.Collections.VariablesCollection.Exists(System.String)">
            <summary>
            RT-Проверить существование переменной
            </summary>
            <param name="keyname">Название переменной</param>
        </member>
        <member name="M:MyCodeLibrary.Collections.VariablesCollection.Remove(System.String)">
            <summary>
            RT-Удалить переменную из коллекции
            </summary>
            <param name="keyname">Название переменной</param>
        </member>
        <member name="M:MyCodeLibrary.Collections.VariablesCollection.Clear">
            <summary>
            RT-Очистить коллекцию переменных
            </summary>
        </member>
        <member name="M:MyCodeLibrary.Collections.VariablesCollection.ListAllItems">
            <summary>
            RT-Получить список переменных коллекции
            В формате "имя" = "значение"
            </summary>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.Collections.VariablesCollection.ToString">
            <summary>
            RT-Получить описание объекта для отладки
            </summary>
            <returns></returns>
        </member>
        <member name="T:MyCodeLibrary.CombinedException">
            <summary>
            Исключение, которое комбиирует нескоько вложенных исключений.
            Для случая пакетной обработки файлов, когда надо все файлы задания попытаться обработать, несмотря на ошибки.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.CombinedException.#ctor(System.String,System.Exception[])">
            <summary>
            	Initializes a new instance of the <see cref = "T:MyCodeLibrary.CombinedException" /> class.
            </summary>
            <param name = "message">The message.</param>
            <param name = "innerExceptions">The inner exceptions.</param>
        </member>
        <member name="P:MyCodeLibrary.CombinedException.InnerExceptions">
            <summary>
            	Gets the inner exceptions.
            </summary>
            <value>The inner exceptions.</value>
        </member>
        <member name="M:MyCodeLibrary.CombinedException.Combine(System.String,System.Exception[])">
            <summary>
            Combines the specified exceptions.
            </summary>
            <param name="message"></param>
            <param name="innerExceptions"></param>
            <returns></returns>
        </member>
        <member name="T:MyCodeLibrary.ConsoleDialogs">
            <summary>
            Класс для функций работы в консольном окне приложения
            </summary>
        </member>
        <member name="M:MyCodeLibrary.ConsoleDialogs.ShowProgressToUser(System.Int32,System.Int32,System.Int32)">
            <summary>
            NT-показать прогресс - сколько сделано из всего
            </summary>
            <param name="all">Сколько всего</param>
            <param name="current">Сколько сделано</param>
            <param name="step">Размер шага, обычно = 16</param>
        </member>
        <member name="T:MyCodeLibrary.CRegistryProcessor">
            <summary>
            NT-
            </summary>
        </member>
        <member name="T:MyCodeLibrary.CRegistryProcessor.HKEY">
            <summary>
            HKEY
            </summary>
        </member>
        <member name="F:MyCodeLibrary.CRegistryProcessor.HKEY.CLASSES_ROOT">
            <summary>
            CLASSES_ROOT
            </summary>
        </member>
        <member name="F:MyCodeLibrary.CRegistryProcessor.HKEY.CURRENT_USER">
            <summary>
            CLASSES_USER
            </summary>
        </member>
        <member name="F:MyCodeLibrary.CRegistryProcessor.HKEY.LOCAL_MACHINE">
            <summary>
            LOCAL_MACHINE
            </summary>
        </member>
        <member name="F:MyCodeLibrary.CRegistryProcessor.HKEY.USERS">
            <summary>
            USERS
            </summary>
        </member>
        <member name="F:MyCodeLibrary.CRegistryProcessor.HKEY.PERFORMANCE_DATA">
            <summary>
            PERFORMANCE_DATA
            </summary>
        </member>
        <member name="F:MyCodeLibrary.CRegistryProcessor.HKEY.CURRENT_CONFIG">
            <summary>
            CURRENT_CONFIG
            </summary>
        </member>
        <member name="M:MyCodeLibrary.CRegistryProcessor.getStringValue(MyCodeLibrary.CRegistryProcessor.HKEY,System.String,System.String)">
            <summary>
            NT-Gets string value of a value in the registry.
            </summary>
            <param name="hkey"></param>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CRegistryProcessor.getByteValue(MyCodeLibrary.CRegistryProcessor.HKEY,System.String,System.String)">
            <summary>
            NT-Gets byte value of a value in the registry.
            </summary>
            <param name="hkey"></param>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CRegistryProcessor.getKeyValue(Microsoft.Win32.RegistryKey,System.String,System.String)">
            <summary>
            NT-
            </summary>
            <param name="hkey"></param>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CRegistryProcessor.getBaseKey(MyCodeLibrary.CRegistryProcessor.HKEY,System.Boolean)">
            <summary>
            NT-
            </summary>
            <param name="hkey"></param>
            <param name="get64"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CRegistryProcessor.getBaseKey32(Microsoft.Win32.RegistryHive)">
            <summary>
            NR-
            </summary>
            <param name="hive"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CRegistryProcessor.getBaseKey64(Microsoft.Win32.RegistryHive)">
            <summary>
            NR-
            </summary>
            <param name="hive"></param>
            <returns></returns>
        </member>
        <member name="T:MyCodeLibrary.FileOperations.FileLink">
            <summary>
            Класс представляет Файловую ссылку file:/
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FileOperations.FileLink.UrlReservedChars">
            <summary>
            Строка зарезервированных для Url символов
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FileOperations.FileLink.m_uncPathName">
            <summary>
            Путь к файлу
            </summary>
        </member>
        <member name="P:MyCodeLibrary.FileOperations.FileLink.UncPath">
            <summary>
            NT - UNC сетевой путь к файлу
            </summary>
        </member>
        <member name="P:MyCodeLibrary.FileOperations.FileLink.LocalPath">
            <summary>
            NR - Локальный путь к файлу
            </summary>
        </member>
        <member name="P:MyCodeLibrary.FileOperations.FileLink.Exists">
            <summary>
            NT- Существует ли файл?
            </summary>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.FileLink.Run">
            <summary>
            NT-Открыть указанный документ через ShellExecute
            </summary>
            <returns>Функция возвращает объект процесса.</returns>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.FileLink.Run(System.Diagnostics.ProcessStartInfo)">
            <summary>
            NT-Открыть указанный документ через ShellExecute
            </summary>
            <param name="info">Параметры запуска процесса.</param>
            <returns>Функция возвращает объект процесса.</returns>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.FileLink.UNCpathToLocalPath(System.String)">
            <summary>
            NR-Конвертировать сетевой путь в локальный путь
            </summary>
            <param name="UNCpath">сетевой путь к документу</param>
            <returns>Возвращает локальный файловый путь к документу</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:MyCodeLibrary.FileOperations.FileLink.LocalPathToUNCpath2(System.String)" -->
        <member name="M:MyCodeLibrary.FileOperations.FileLink.LocalPathToUNCpath(System.String)">
            <summary>
            NT-Конвертировать локальный путь в сетевой путь.
            Возвращает пустую строку при ошибке.
            </summary>
            <param name="localPath">Локальный файловый путь к документу</param>
            <returns>
            Возвращает сетевой путь к файлу.
            Возвращает пустую строку при ошибке.
            </returns>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.FileLink.urlQuote(System.String,System.String)">
            <summary>
            Экранировать символы в строке подобно %20, для их совместимости с Url
            </summary>
            <param name="path">строка для экранирования</param>
            <param name="safe">строка символов, не подлежащих экранированию</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.FileLink.makeUriFromRelativeFilePath(System.String,System.String)">
            <summary>
            NT-Собрать сетевой путь к файлу из относительного или абсолютного пути к файлу
            </summary>
            <param name="rootpath">Начальная часть пути для относительного пути файла</param>
            <param name="text">Относительный или абсолютный путь к файлу, или ссылка вида file:///C:/data.dat или file:///data.dat </param>
            <returns>
            Если файл собран правильно, возвращается сетевая ссылка на файл, пригодная для использования в оболочке Винды.
            Если файл не существует, или возникает любая ошибка, возвращается String.Empty.
            </returns>
        </member>
        <member name="T:MyCodeLibrary.FileOperations.CFileOperations">
            <summary>
            Общие операции с файлами
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FileOperations.CFileOperations.ShortcutFileExtension">
            <summary>
            Расширение файла-ярлыка
            </summary>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.IsShortcutFile(System.String)">
            <summary>
            NT-Проверить по расширению файла, что файл является ярлыком.
            </summary>
            <param name="notePath">Путь к файлу-ярлыку</param>
            <returns>True если это файл-ярлык</returns>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.ReplaceInvalidFilenameChars(System.String,System.Char)">
            <summary>
            Заменить неправильные символы пути файла в строке на указанный символ
            </summary>
            <param name="s">Строка пути файла</param>
            <param name="rChar">Символ на замену</param>
            <returns>Возвращает строку не содержащую неправильных символов имени файла</returns>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.makeSafeFileTitle(System.String)">
            <summary>
            NT-Заменить все символы не подходящие для файловых путей на _
            </summary>
            <param name="chapTitle"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.createTemporaryFolder(System.String)">
            <summary>
            NT-Создать временный каталог со случайным именем и расширением
            </summary>
            <param name="tempFolderPath">Родительский каталог для создаваемого временного каталога</param>
            <returns>Возвращает путь к созданному временному каталогу.</returns>
            <remarks>
            Функция перебирает случайные имена каталогов, чтобы получить незанятое имя для нового каталога.
            Если 1024 попытки не удались, выдается исключение.
            </remarks>
        </member>
        <member name="F:MyCodeLibrary.FileOperations.CFileOperations.RestrictedFileNames">
            <summary>
            Массив запрещенных имен файлов - для коррекции имен файлов
            </summary>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.isRestrictedFileName(System.String)">
            <summary>
            NT-Проверить, что имя файла является неправильным
            Это не совсем правильная функция: для имен, содержащих точку, лишь первая часть (до первой точки) вызывает исключение.
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.makeSafeFiletitle(System.String,System.String,System.String,System.String)">
             <summary>
             RT-Заменить в названии файла все не подходящие для файловых путей символы на указанные
             </summary>
             <param name="filetitle">Исходное название файла, без расширения</param>
             <param name="wrongSymbols">Добавочные символы, помимо Path.GetInvalidFileNameChars(), нежелательные в названии файла</param>
             <param name="replacement">Строка, которой заменяются неправильные символы. Обычно это "_" или "-".</param>
             <param name="titleTemplate">Шаблонное название файла, используемое в случае, когда исходное название не содержит никаких символов.</param>
             <returns>Функция возвращает исправленное название файла.</returns>
             <remarks>
             Проверено 04 ноября 2019 г.
             Создание файлов функцией File.Create(..):
             "" ==> "file" : C:\Temp\.txt Success
             " " ==> "file" : C:\Temp\ .txt Success
             " . " ==> "." : C:\Temp\ . .txt Success
             ".." ==> ".." : C:\Temp\...txt Success
             "-." ==> "-." : C:\Temp\-..txt Success
             "con" ==> "con-" : C:\Temp\con.txt System.ArgumentException
             ".con" ==> ".con" : C:\Temp\.con.txt Success
             "con." ==> "con-." : C:\Temp\con..txt System.ArgumentException
             "f.con.con" ==> "f.con.con" : C:\Temp\f.con.con.txt Success
             "con.f" ==> "con-.f" : C:\Temp\con.f.txt System.ArgumentException
             "файл.con" ==> "файл.con" : C:\Temp\файл.con.txt Success
             "файл" ==> "файл" : C:\Temp\файл.txt Success
             ".файл" ==> ".файл" : C:\Temp\.файл.txt Success
             "aux.файл" ==> "aux-.файл" : C:\Temp\aux.файл.txt System.ArgumentException
             
             Создание файлов после обработки функцией makeSafeFiletitle(..):
             "" ==> "file" : C:\Temp\file.txt Success
             " " ==> "file" : C:\Temp\file.txt Success
             " . " ==> "." : C:\Temp\..txt Success
             ".." ==> ".." : C:\Temp\...txt Success
             "-." ==> "-." : C:\Temp\-..txt Success
             "con" ==> "con-" : C:\Temp\con-.txt Success
             ".con" ==> ".con" : C:\Temp\.con.txt Success
             "con." ==> "con-." : C:\Temp\con-..txt Success
             "f.con.con" ==> "f.con.con" : C:\Temp\f.con.con.txt Success
             "con.f" ==> "con-.f" : C:\Temp\con-.f.txt Success
             "файл.con" ==> "файл.con" : C:\Temp\файл.con.txt Success
             "файл" ==> "файл" : C:\Temp\файл.txt Success
             ".файл" ==> ".файл" : C:\Temp\.файл.txt Success
             "aux.файл" ==> "aux-.файл" : C:\Temp\aux-.файл.txt Success
             </remarks>
             <example>
             <code>
             static void Main(string[] args)
             {
                 String[] wrongTitles = new String[] { "", " ", " . ", "..", "-.", "con", ".con", "con.", "f.con.con", "con.f", "файл.con", "файл", ".файл", "aux.файл" };
                 foreach (String s in wrongTitles)
                 {
                     String t = makeSafeFiletitle(s, "#", "-", "file");
                     Console.WriteLine("\"{0}\" ==> \"{1}\" : {2}", s, t, tryCreateFile(t));
                 }
                 Console.ReadLine();
             }
            
            
             // Попытаемся создать файл с указанным названием во временном каталоге
             private static object tryCreateFile(string s)
             {
                 String result = "C:\\Temp\\" + s + ".txt";
                 try
                 {
                     FileStream fs = System.IO.File.Create(result);
                     fs.Close();
                     result = result + " Success";
                 }
                 catch (Exception ex)
                 {
                     result = result + " " + ex.GetType().ToString();
                 }
                 return result;
             }
             </code> 
             </example>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.getFileCrc(System.String)">
            <summary>
            NT- Вычислить CRC32 для файла
            </summary>
            <param name="filepath">Путь к файлу</param>
            <returns>Возвращает CRC32</returns>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.createFreeFileName(System.String)">
            <summary>
            NT-Создать свободное имя файла в том же каталоге
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.CompareStreams(System.IO.Stream,System.IO.Stream)">
            <summary>
            NT-Проверить что содержимое потоков одинаковое
            </summary>
            <param name="zs">Поток 1</param>
            <param name="fs">Поток 2</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.CompareFiles(System.String,System.String)">
            <summary>
            NT- compare two files
            </summary>
            <param name="filePath"></param>
            <param name="file2"></param>
            <returns></returns>
        </member>
        <member name="F:MyCodeLibrary.FileOperations.CFileOperations.RestrictedWebLinkSymbols">
            <summary>
            Массив запрещенных для веб-имен символов - здесь для оптимизации функции проверки веб-имен 
            </summary>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.RemoveWrongSymbols(System.String,System.Int32)">
            <summary>
            NFT-Нормализовать имя файла или каталога
            </summary>
            <param name="title">имя файла без расширения</param>
            <param name="maxLength">Максимальная длина имени, в символах</param>
            <returns>Возвращает нормализованное название файла или каталога, без расширения.</returns>
            <remarks>
            Функция заменяет на подчеркивания _ все символы, кроме букв и цифр.
            Если в названии есть пробелы, они удаляются, а следующий символ переводится в верхний регистр.
            Если в названии есть символ 'µ', он заменяется на символ 'u'.
            Если получившееся название длиннее maxLength, то оно обрезается до maxLength.
            Если получившееся название является зарезервированным системным названием (вроде CON), или
            если получившееся название короче 3 символов, к нему добавляется случайное число.
            </remarks>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.RemoveWrongSymbols(System.String)">
            <summary>
            NFT-Нормализовать имя файла или каталога
            </summary>
            <param name="title">имя файла без расширения</param>
            <returns>Возвращает нормализованное название файла или каталога, без расширения.</returns>
            <remarks>
            Функция заменяет на подчеркивания _ все символы, кроме букв и цифр.
            Если в названии есть пробелы, они удаляются, а следующий символ переводится в верхний регистр.
            Если в названии есть символ 'µ', он заменяется на символ 'u'.
            Если получившееся название длиннее maxLength, то оно обрезается до maxLength.
            Если получившееся название является зарезервированным системным названием (вроде CON), или
            если получившееся название короче 3 символов, к нему добавляется случайное число.
            </remarks>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.DeleteFile(System.String)">
            <summary>
            Удалить файл, изменив его атрибуты на нормальные.
            Если файл не существует, исключение не выбрасывается.
            </summary>
            <param name="filepath">Путь к файлу</param>
            <remarks>
            Обычно, если файл имеет атрибуты Архивный или ReadOnly, функция File.Delete() вместо удаления выдает исключение.
            Эта функция сначала снимает атрибуты, а затем выполняет удаление.
            Это мелочь, которая упрощает написание кода.
            </remarks>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.CreateNotIndexedFolder(System.String)">
            <summary>
            NT-Создать каталог, в котором запрещено индексирование средствами операционной системы
            </summary>
            <param name="folderPath">Путь к создаваемому каталогу</param>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.СоздатьФайлБезИндексирования(System.String)">
            <summary>
            RT-Создать новый файл или перезаписать существующий
            </summary>
            <param name="p">Путь файла</param>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.ПолучитьАбсолютныйПуть1(System.String,System.String)">
            <summary>
            RT-Сделать абсолютный путь из относительного, если путь не абсолютный.
            </summary>
            <param name="refPath">Обрабатываемый путь, абсолютный или относительный</param>
            <param name="basePath">Базовый абсолютный путь</param>
            <returns>Возвращает абсолютный путь</returns>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.makeAbsolutePath(System.String,System.String)">
            <summary>
            RT-Вернуть абсолютный путь к каталогу
            </summary>
            <param name="basedir">Абсолютный путь основного каталога</param>
            <param name="localPath">Относительный или абсолютный путь конечного каталога</param>
            <returns>Функция возвращает абсолютный путь к конечному каталогу</returns>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.makeRelativePath(System.String,System.String)">
            <summary>
            RT-Вернуть относительный (если возможно) или абсолютный путь к каталогу
            </summary>
            <param name="basedir">Абсолютный путь основного каталога</param>
            <param name="absolutePath">Относительный или абсолютный путь конечного каталога</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.IsAbsolutePath(System.String)">
            <summary>
            RT-Убедиться что файловый путь является абсолютным
            </summary>
            <param name="p">Проверяемый файловый путь, не сетевой.</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.ПолучитьРазмерСвободногоМестаНаТоме(System.String)">
            <summary>
            RT-получить размер свободного места на диске.
            С учетом дисковой квоты пользователя, итп.
            </summary>
            <param name="volume">Буква тома</param>
            <returns>Размер свободного места на томе</returns>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.GetDirectorySize(System.String)">
            <summary>
            NT-Получить размер указанного каталога
            </summary>
            <param name="dirpath">Путь к каталогу</param>
            <returns>Возвращает размер указанного каталога в байтах</returns>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.getDirectorySizeRecursive(System.IO.DirectoryInfo)">
            <summary>
            NT-Получить размер указанного каталога рекурсивно
            </summary>
            <param name="d">Объект каталога</param>
            <returns>Возвращает размер указанного каталога в байтах</returns>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.getSrcFiles(System.String,System.String[],System.IO.SearchOption)">
            <summary>
            NT-Получить из каталога файлы, соответствующие допустимым расширениям файлов.
            </summary>
            <param name="srcFolder">Путь к папке проекта.</param>
            <param name="exts">Допустимые расширения файлов, с точкой.</param>
            <param name="option">Способ поиска в каталогах.</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.isAllowedExtension(System.String,System.String[])">
            <summary>
            NT-убедиться, что файл имеет допустимое расширение.
            </summary>
            <param name="s">Путь к файлу</param>
            <param name="exts">Допустимые расширения файлов, с точкой</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.getFiles(System.String,System.IO.SearchOption)">
            <summary>
            NT-Получить все файлы из каталога
            </summary>
            <param name="srcFolder">Путь к папке проекта</param>
            <param name="option">Способ поиска в каталогах.</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.recursiveGetFiles(System.Collections.Generic.List{System.String},System.IO.DirectoryInfo,System.IO.SearchOption)">
            <summary>
            NT-Рекурсивная функция обхода каталогов
            </summary>
            <param name="result">Список найденных путей файлов.</param>
            <param name="di"><c>DirectoryInfo</c> просматриваемого каталога.</param>
            <param name="option">Способ поиска в каталогах.</param>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.getCounterDictionaryOfFileExtensions(System.String,System.IO.SearchOption)">
            <summary>
            NT-Получить словарь счетчиков расширений файлов, размещающихся в указанном каталоге.
            </summary>
            <param name="folder">Путь к каталогу, в котором производится поиск</param>
            <param name="option">Искать ли во вложенных каталогах</param>
            <returns>Возвращает словарь счетчиков расширений файлов</returns>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.recursiveGetExtensions(System.Collections.Generic.Dictionary{System.String,System.Int32},System.IO.DirectoryInfo,System.IO.SearchOption)">
            <summary>
            NT-Служебная функция рекурсивного обхода каталога
            </summary>
            <param name="dic">Словарь счетчиков расширений</param>
            <param name="di">DirectoryInfo объект просматриваемого каталога</param>
            <param name="option">Искать ли во вложенных каталогах</param>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.getFolderFilesByExts(System.String,System.String,System.IO.SearchOption)">
            <summary>
            NT-Возвращает массив путей файлов с указаными расширениями 
            </summary>
            <param name="extensions">
            Строка с расширениями файлов. Пример: ".txt .diz" 
            </param>
            <param name="folder">Путь к каталогу, в котором производится поиск</param>
            <param name="option">Искать ли во вложенных каталогах</param>
            <returns>Возвращает массив путей файлов с указаными расширениями </returns>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.getFolderFilesByExts(System.String,System.String[],System.IO.SearchOption)">
            <summary>
            NT-Возвращает массив путей файлов с указанными расширениями 
            </summary>
            <param name="folder">Путь к каталогу, в котором производится поиск</param>
            <param name="fileExtensions">Массив с расширениями искомых файлов</param>
            <param name="option">Искать ли во вложенных каталогах</param>
            <returns>Возвращает массив путей файлов с указанными расширениями</returns>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.parseFileExtensionsString(System.String)">
            <summary>
            NT-Разделяет строку расширений файлов на массив расширений файлов
            </summary>
            <param name="extensions">
            Строка с расширениями файлов. 
            Расширение начинается с точки и отделяется пробелом
            Пример: ".txt .diz" 
            </param>
            <returns>Возвращает массив строк расширений файлов</returns>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.createDocTypeFromFileExtension(System.String)">
            <summary>
            NT-убирает точку и делает следующую букву в верхний регистр.
            Пример: .pdf -> Pdf
            </summary>
            <param name="p">расширение файла: .pdf</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:MyCodeLibrary.FileOperations.CFileOperations.getTitleOfNewSubfolder(System.String,System.String)" -->
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.Rename(System.IO.FileInfo,System.String)">
            <summary>
            Renames a file.
            </summary>
            <param name = "file">The file.</param>
            <param name = "newName">The new name.</param>
            <returns>The renamed file</returns>
            <example>
            	<code>
            		var file = new FileInfo(@"c:\test.txt");
            		file.Rename("test2.txt");
            	</code>
            </example>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.RenameFileWithoutExtension(System.IO.FileInfo,System.String)">
            <summary>
            Renames a file without changing its extension.
            </summary>
            <param name = "file">The file.</param>
            <param name = "newName">The new name.</param>
            <returns>The renamed file</returns>
            <example>
            	<code>
            		var file = new FileInfo(@"c:\test.txt");
            		file.RenameFileWithoutExtension("test3");
            	</code>
            </example>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.ChangeExtension(System.IO.FileInfo,System.String)">
            <summary>
            Changes the files extension.
            </summary>
            <param name = "file">The file.</param>
            <param name = "newExtension">The new extension.</param>
            <returns>The renamed file</returns>
            <example>
            	<code>
            		var file = new FileInfo(@"c:\test.txt");
            		file.ChangeExtension("xml");
            	</code>
            </example>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.ChangeExtensions(System.IO.FileInfo[],System.String)">
            <summary>
            Changes the extensions of several files at once.
            </summary>
            <param name = "files">The files.</param>
            <param name = "newExtension">The new extension.</param>
            <returns>The renamed files</returns>
            <example>
            	<code>
            		var files = directory.GetFiles("*.txt", "*.xml");
            		files.ChangeExtensions("tmp");
            	</code>
            </example>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.Delete(System.IO.FileInfo[])">
            <summary>
            Deletes several files at once and consolidates any exceptions.
            </summary>
            <param name = "files">The files.</param>
            <example>
            	<code>
            		var files = directory.GetFiles("*.txt", "*.xml");
            		files.Delete()
            	</code>
            </example>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.Delete(System.IO.FileInfo[],System.Boolean)">
            <summary>
            Deletes several files at once and optionally consolidates any exceptions.
            </summary>
            <param name = "files">The files.</param>
            <param name = "consolidateExceptions">if set to <c>true</c> exceptions are consolidated and the processing is not interrupted.</param>
            <example>
            	<code>
            		var files = directory.GetFiles("*.txt", "*.xml");
            		files.Delete()
            	</code>
            </example>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.CopyTo(System.IO.FileInfo[],System.String)">
            <summary>
            Copies several files to a new folder at once and consolidates any exceptions.
            </summary>
            <param name = "files">The files.</param>
            <param name = "targetPath">The target path.</param>
            <returns>The newly created file copies</returns>
            <example>
            	<code>
            		var files = directory.GetFiles("*.txt", "*.xml");
            		var copiedFiles = files.CopyTo(@"c:\temp\");
            	</code>
            </example>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.CopyTo(System.IO.FileInfo[],System.String,System.Boolean)">
            <summary>
            Copies several files to a new folder at once and optionally consolidates any exceptions.
            </summary>
            <param name = "files">The files.</param>
            <param name = "targetPath">The target path.</param>
            <param name = "consolidateExceptions">if set to <c>true</c> exceptions are consolidated and the processing is not interrupted.</param>
            <returns>The newly created file copies</returns>
            <example>
            	<code>
            		var files = directory.GetFiles("*.txt", "*.xml");
            		var copiedFiles = files.CopyTo(@"c:\temp\");
            	</code>
            </example>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.MoveTo(System.IO.FileInfo[],System.String)">
            <summary>
            Moves several files to a new folder at once and optionally consolidates any exceptions.
            </summary>
            <param name = "files">The files.</param>
            <param name = "targetPath">The target path.</param>
            <returns>The moved files</returns>
            <example>
            	<code>
            		var files = directory.GetFiles("*.txt", "*.xml");
            		files.MoveTo(@"c:\temp\");
            	</code>
            </example>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.MoveTo(System.IO.FileInfo[],System.String,System.Boolean)">
            <summary>
            Moves several files to a new folder at once and optionally consolidates any exceptions.
            </summary>
            <param name = "files">The files.</param>
            <param name = "targetPath">The target path.</param>
            <param name = "consolidateExceptions">if set to <c>true</c> exceptions are consolidated and the processing is not interrupted.</param>
            <returns>The moved files</returns>
            <example>
            	<code>
            		var files = directory.GetFiles("*.txt", "*.xml");
            		files.MoveTo(@"c:\temp\");
            	</code>
            </example>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.SetAttributes(System.IO.FileInfo[],System.IO.FileAttributes)">
            <summary>
            Sets file attributes for several files at once
            </summary>
            <param name = "files">The files.</param>
            <param name = "attributes">The attributes to be set.</param>
            <returns>The changed files</returns>
            <example>
            	<code>
            		var files = directory.GetFiles("*.txt", "*.xml");
            		files.SetAttributes(FileAttributes.Archive);
            	</code>
            </example>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.SetAttributesAdditive(System.IO.FileInfo[],System.IO.FileAttributes)">
            <summary>
            Appends file attributes for several files at once (additive to any existing attributes)
            </summary>
            <param name = "files">The files.</param>
            <param name = "attributes">The attributes to be set.</param>
            <returns>The changed files</returns>
            <example>
            	<code>
            		var files = directory.GetFiles("*.txt", "*.xml");
            		files.SetAttributesAdditive(FileAttributes.Archive);
            	</code>
            </example>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.GetFiles(System.IO.DirectoryInfo,System.String[])">
            <summary>
            Gets all files in the directory matching one of the several (!) supplied patterns (instead of just one in the regular implementation).
            </summary>
            <param name = "directory">The directory.</param>
            <param name = "patterns">The patterns.</param>
            <returns>The matching files</returns>
            <remarks>
            Выходной массив может содержать повторы путей файлов!	
            </remarks>
            <example>
            	<code>
            		var files = directory.GetFiles("*.txt", "*.xml");
            	</code>
            </example>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.FindFileRecursive(System.IO.DirectoryInfo,System.String)">
            <summary>
            Searches the provided directory recursively and returns the first file matching the provided pattern.
            </summary>
            <param name = "directory">The directory.</param>
            <param name = "pattern">The pattern.</param>
            <returns>The found file</returns>
            <example>
            	<code>
            		var directory = new DirectoryInfo(@"c:\");
            		var file = directory.FindFileRecursive("win.ini");
            	</code>
            </example>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.FindFilesRecursive(System.IO.DirectoryInfo,System.String)">
            <summary>
            Searches the provided directory recursively and returns the all files matching the provided pattern.
            </summary>
            <param name = "directory">The directory.</param>
            <param name = "pattern">The pattern.</param>
            <remarks>
            	This methods is quite perfect to be used in conjunction with the newly created FileInfo-Array extension methods.
            </remarks>
            <returns>The found files</returns>
            <example>
            	<code>
            		var directory = new DirectoryInfo(@"c:\");
            		var files = directory.FindFilesRecursive("*.ini");
            	</code>
            </example>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.FindFilesRecursive(System.IO.DirectoryInfo,System.String,System.Collections.Generic.List{System.IO.FileInfo})">
            <summary>
            Subfunction for FindFilesRecursive
            </summary>
            <param name="directory"></param>
            <param name="pattern"></param>
            <param name="foundFiles"></param>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.CopyTo(System.IO.DirectoryInfo,System.String)">
            <summary>
            Copies the entire directory to another one
            </summary>
            <param name="sourceDirectory">The source directory.</param>
            <param name="targetDirectoryPath">The target directory path.</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.CFileOperations.CopyTo(System.IO.DirectoryInfo,System.IO.DirectoryInfo)">
            <summary>
            Copies the entire directory to another one
            </summary>
            <param name="sourceDirectory">The source directory.</param>
            <param name="targetDirectory">The target directory.</param>
        </member>
        <member name="T:MyCodeLibrary.FileOperations.FileStorageStatistics">
            <summary>
            Подсчитывает статистику для каталога - размер каталога и число файлов и подкаталогов
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FileOperations.FileStorageStatistics.m_FilesCount">
            <summary>
            Число файлов
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FileOperations.FileStorageStatistics.m_FoldersCount">
            <summary>
            Число подкаталогов
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FileOperations.FileStorageStatistics.m_FolderSize">
            <summary>
            Размер каталога в байтах
            </summary>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.FileStorageStatistics.#ctor(System.String)">
            <summary>
            Создает данные статистики
            </summary>
            <param name="folderPath">Путь к обрабатываемому каталогу</param>
        </member>
        <member name="P:MyCodeLibrary.FileOperations.FileStorageStatistics.FoldersCount">
            <summary>
            Число подкаталогов
            </summary>
        </member>
        <member name="P:MyCodeLibrary.FileOperations.FileStorageStatistics.FilesCount">
            <summary>
            Число файлов
            </summary>
        </member>
        <member name="P:MyCodeLibrary.FileOperations.FileStorageStatistics.FolderSize">
            <summary>
            Размер каталога в байтах
            </summary>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.FileStorageStatistics.getDirStat(System.IO.DirectoryInfo)">
            <summary>
            NT-Рекурсивно проходим по каталогам и собираем статистику
            </summary>
            <param name="d">DirectoryInfo object of parent directory</param>
        </member>
        <member name="T:MyCodeLibrary.FileOperations.ShellFileOperations">
            <summary>
            Использует Windows Shell подсистему для выполнения файловых операций с возможностью их отмены пользователем.
            + Функция очистки корзины 
            </summary>
        </member>
        <member name="T:MyCodeLibrary.FileOperations.ShellFileOperations.FileOperationType">
            <summary>
            Перечисление FileOperationType для функции определяет, что делать с файлом.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FileOperations.ShellFileOperations.FileOperationType.FO_MOVE">
            <summary>
            Переместить файл
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FileOperations.ShellFileOperations.FileOperationType.FO_COPY">
            <summary>
            Копировать файл
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FileOperations.ShellFileOperations.FileOperationType.FO_DELETE">
            <summary>
            Удалить (в корзину или безвозвратно) файл
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FileOperations.ShellFileOperations.FileOperationType.FO_RENAME">
            <summary>
            Переименовать файл
            </summary>
        </member>
        <member name="T:MyCodeLibrary.FileOperations.ShellFileOperations.FileOperationFlags">
            <summary>
            Необходимые флаги для функции SHFileOperation.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FileOperations.ShellFileOperations.FileOperationFlags.FOF_MULTIDESTFILES">
            <summary>
            
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FileOperations.ShellFileOperations.FileOperationFlags.FOF_SILENT">
            <summary>
            Не показывать диалог с индикатором прогресса в течение процесса удаления.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FileOperations.ShellFileOperations.FileOperationFlags.FOF_NOCONFIRMATION">
            <summary>
            Не спрашивать у пользователя подтверждения удаления.
            Show no confirmation dialog box to the user.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FileOperations.ShellFileOperations.FileOperationFlags.FOF_ALLOWUNDO">
            <summary>
            Удалить файл в корзину. Этот флаг нужен для того, чтобы файл был удален именно в корзину.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FileOperations.ShellFileOperations.FileOperationFlags.FOF_SIMPLEPROGRESS">
            <summary>
            Не показывать, какие файлы и\или папки удаляются, в диалоге с индикатором прогресса.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FileOperations.ShellFileOperations.FileOperationFlags.FOF_NOCONFIRMMKDIR">
            <summary>
            
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FileOperations.ShellFileOperations.FileOperationFlags.FOF_NOERRORUI">
            <summary>
            Не показывать сообщения об ошибках, которые могут возникнуть в течение процесса.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FileOperations.ShellFileOperations.FileOperationFlags.FOF_WANTNUKEWARNING">
            <summary>
            Предупреждать, что удаляемые файлы слишком велики для помещения в корзину и поэтому
            будут удалены безвозвратно.
            </summary>
            <remarks>
            // Windows 2000 and later
            </remarks>
        </member>
        <member name="T:MyCodeLibrary.FileOperations.ShellFileOperations.SHFILEOPSTRUCT_x86">
            <summary>
            SHFILEOPSTRUCT для функции. Здесь два объявления самой функции и этой структуры,
            используемые в зависимости от разрядности системы
            </summary>
        </member>
        <member name="P:MyCodeLibrary.FileOperations.ShellFileOperations.IsWOW64Process">
            <summary>
            32-битная или 64-битная система?
            </summary>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.ShellFileOperations.shellFileOp2(System.Boolean@,MyCodeLibrary.FileOperations.ShellFileOperations.FileOperationType,MyCodeLibrary.FileOperations.ShellFileOperations.FileOperationFlags,System.String,System.String)">
            <summary>
            Собственно файловая операция 
            Тут можно указать много всяких параметров.
            </summary>
            <param name="Cancelled">Флаг что операция была отменена пользователем</param>
            <param name="opCode">Код операции, один из: FO_COPY FO_MOVE FO_DELETE</param>
            <param name="opFlags">Флаги поведения операции</param>
            <param name="srcPath">Абсолютный путь к исходному файлу или каталогу</param>
            <param name="dstPath">Асолютный путь к конечному файлу или каталогу, null если не нужен</param>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.ShellFileOperations.CopyFile(System.String,System.String)">
            <summary>
            NT-Копировать файл или каталог с показом диалога и возможностью отменить операцию.
            </summary>
            <param name="srcPath">Путь к исходному файлу</param>
            <param name="dstPath">Путь к конечному файлу</param>
            <returns>Функция возвращает true, если операция была выполнена успешно, false если операция прервана пользователем.</returns>
            <remarks>HTML файлы обрабатываются вместе с принадлежащими им папками ресурсов, если в Проводнике установлен соответствующий флаг.</remarks>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.ShellFileOperations.MoveFile(System.String,System.String)">
            <summary>
            NT-Переместить файл или каталог с показом диалога и возможностью отменить операцию.
            </summary>
            <param name="srcPath">Путь к исходному файлу</param>
            <param name="dstPath">Путь к конечному файлу</param>
            <returns>Функция возвращает true, если операция была выполнена успешно, false если операция прервана пользователем.</returns>
            <remarks>HTML файлы обрабатываются вместе с принадлежащими им папками ресурсов, если в Проводнике установлен соответствующий флаг.</remarks>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.ShellFileOperations.DeleteFile(System.String)">
            <summary>
            NT-Удалить файл или каталог с показом диалога и возможностью отменить операцию.
            </summary>
            <param name="srcPath">Путь к удаляемому файлу</param>
            <returns>Функция возвращает true, если операция была выполнена успешно, false если операция прервана пользователем.</returns>
            <remarks>
            Файл удаляется в Корзину Windows.
            HTML файлы обрабатываются вместе с принадлежащими им папками ресурсов, если в Проводнике установлен соответствующий флаг.
            </remarks>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.ShellFileOperations.DeleteFile(System.String,MyCodeLibrary.FileOperations.ShellFileOperations.FileOperationFlags)">
            <summary>
            NT-Удалить файл или каталог с показом диалога и возможностью отменить операцию.
            </summary>
            <param name="srcPath">Путь к удаляемому файлу</param>
            <param name="flags">Флаги поведения операции</param>
            <returns>Функция возвращает true, если операция была выполнена успешно, false если операция прервана пользователем.</returns>
            <remarks>
            HTML файлы обрабатываются вместе с принадлежащими им папками ресурсов, если в Проводнике установлен соответствующий флаг.
            </remarks>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.ShellFileOperations.DeleteFileOrFolder(System.String)">
            <summary>
            Устаревшая функция!
            Переместить файл или папку в корзину
            </summary>
            <param name="path">Путь к папке или файлу</param>
        </member>
        <member name="T:MyCodeLibrary.FileOperations.ShellFileOperations.EmptyRecycleBinFlags">
            <summary>
            Флаги для API-функции SHEmptyRecycleBin
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FileOperations.ShellFileOperations.EmptyRecycleBinFlags.None">
            <summary>
            Нет флагов (=0)
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FileOperations.ShellFileOperations.EmptyRecycleBinFlags.SHERB_NOCONFIRMATION">
            <summary>
            Не отображать диалог с уведомлением об удалении объектов
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FileOperations.ShellFileOperations.EmptyRecycleBinFlags.SHERB_NOPROGRESSUI">
            <summary>
            Не отображать диалог с индикатором прогресса
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FileOperations.ShellFileOperations.EmptyRecycleBinFlags.SHERB_NOSOUND">
            <summary>
            Когда операция закончится, не пригрывать звук
            </summary>
        </member>
        <member name="M:MyCodeLibrary.FileOperations.ShellFileOperations.EmptyRecycleBin(System.IntPtr,System.String,MyCodeLibrary.FileOperations.ShellFileOperations.EmptyRecycleBinFlags)">
            <summary>
            NFT-Очистить корзину
            </summary>
            <param name="hWnd"> handle to the parent window of any dialog boxes that might be displayed during the operation. This parameter can be NULL.</param>
            <param name="volumeRootPath">
            The address of a null-terminated string of maximum length MAX_PATH that 
            contains the path of the root drive on which the Recycle Bin is located. 
            This parameter can contain the address of a string formatted with the drive, 
            folder, and subfolder names, for example c:\windows\system\, etc. 
            It can also contain an empty string or NULL. 
            If this value is an empty string or NULL, all Recycle Bins on all drives will be emptied.</param>
            <param name="flags">Флаги поведения операции</param>
            <returns>
            Возвращает True при успехе или False при ошибке.
            </returns>
        </member>
        <member name="T:MyCodeLibrary.FileStorageV2.FileStorageManagerV2">
            <summary>
            Менеджер файлового хранилища для проекта
            </summary>
            <remarks>
            Это менеджер для хранения файлов по подобию Wikidpad. 
            Для текстового редактора, использующего ссылки на файлы.
            Например, для Инвентарь.
            </remarks>
        </member>
        <member name="F:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.FileCountLimit">
            <summary>
            Предельное число пользовательских папок и файлов в подкаталоге хранилища
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.m_FolderCountLimit">
            <summary>
            Предельное число каталогов хранилища в корневом каталоге хранилища
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.m_StorageRootFolderPath">
            <summary>
            Путь к корневому каталогу хранилища
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.m_canWrite">
            <summary>
            Режим read-only для хранилища
            </summary>
        </member>
        <member name="F:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.m_Randomizer">
            <summary>
            Генератор случайных чисел для функции быстрого добавления файлов
            </summary>
        </member>
        <member name="M:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.#ctor(System.String)">
            <summary>
            Создать менеджер файлового хранилища
            </summary>
            <param name="storageRootFolderPath">Путь к каталогу Хранилища</param>
        </member>
        <member name="P:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.CanWrite">
            <summary>
            Установить или получить режим read-only хранилища
            </summary>
        </member>
        <member name="P:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.StorageRootFolderPath">
            <summary>
            Путь к корневому каталогу хранилища
            </summary>
        </member>
        <member name="M:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.IsCanWrite">
            <summary>
            NT-Проверить, что хранилище физически доступно для записи
            </summary>
            <remarks>
            Функция устанавливает флаг CanWrite.
            Если хранилище не существует, но запись возможна, то оно создается.
            </remarks>
        </member>
        <member name="M:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.IsStorageExists">
            <summary>
            NT-Проверить, что файловое хранилище существует
            </summary>
        </member>
        <member name="M:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.EnsureStorageWritable">
            <summary>
            NT-Проверить и при необходимости создать файловое хранилище
            </summary>
        </member>
        <member name="M:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.DeleteStorage(System.Boolean)">
            <summary>
            NT-Удалить хранилище
            </summary>
            <param name="useTrashcan">true  - переместить в Корзину Windows, false - удалять.</param>
            <returns>Возвращает True, если хранилище было удалено, False если нет.</returns>
        </member>
        <member name="M:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.CreateStorage">
            <summary>
            NT-Создать новое хранилище
            </summary>
            <returns>Возвращает True если создание удалось, False если не удалось</returns>
        </member>
        <member name="M:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.CreateStorageFolder(System.String)">
            <summary>
            NT-Создать папку для структуры хранилища  и установить атрибут неиндексирования
            </summary>
            <param name="pathname">Абсолютный путь к папке</param>
            <returns>Возвращает True если создание удалось, False если не удалось</returns>
        </member>
        <member name="M:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.CheckFileExists(System.String)">
            <summary>
            NT-Проверить наличие файла или папки по относительному пути
            </summary>
            <param name="relFilePath">Путь к проверяемому файлу относительно корневой папки хранилища</param>
        </member>
        <member name="M:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.ConvertAbsoluteToRelativePath(System.String)">
            <summary>
            NT-Получить относительный путь по абсолютному
            </summary>
            <param name="absolutePath">Абсолютный путь к файлу</param>
            <returns>Возвращает относительный путь к хранилищу или null, если не удалось создать относительный путь</returns>
        </member>
        <member name="M:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.ConvertRelativeToAbsolutePath(System.String)">
            <summary>
            NT-Получить абсолютный путь по относительному
            </summary>
            <param name="relativePath">Путь к файлу относительно корневой папки хранилища</param>
        </member>
        <member name="M:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.SafeRemoveFile(System.String,System.Boolean)">
            <summary>
            NT-Удалить файл или каталог с учетом его блокировки службой индексации или сторонней программой
            </summary>
            <param name="filepath">Абсолютный путь к файлу или каталогу</param>
            <param name="useTrashcan">true  - переместить в Корзину Windows, false - удалять.</param>
            <returns>Возвращает True если файл удален, False если возникла ошибка или пользователь отменил операцию.</returns>
        </member>
        <member name="M:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.IsEqualFileContent(System.String,System.String)">
            <summary>
            NT-Сравнить два файла по содержимому
            </summary>
            <param name="filepath1">Абсолютный путь к первому сравниваемому  файлу</param>
            <param name="filepath2">Абсолютный путь ко второму сравниваемому  файлу</param>
        </member>
        <member name="M:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.IsEqualFolderContent(System.String,System.String)">
            <summary>
            NR-Сравнить два каталога по содержимому
            </summary>
            <param name="testFolderPath">Абсолютный путь к первому сравниваемому каталогу</param>
            <param name="srcFolderPath">Абсолютный путь ко второму сравниваемому каталогу</param>
            <returns>Возвращает True если оба каталога одинаковы, False в противном случае</returns>
        </member>
        <member name="M:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.IsFolder(System.String)">
            <summary>
            NT-Проверить, является ли указанный файл каталогом 
            </summary>
            <param name="filepath">Путь к файлу или каталогу</param>
            <returns>Возвращает True если путь указывает на каталог. False, если это не каталог.</returns>
        </member>
        <member name="M:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.AddFileAnyway(System.String,System.Boolean)">
            <summary>
            NT-Добавить файл в хранилище
            </summary>
            <param name="filePathName">Абсолютный путь к добавляемому  файлу или каталогу</param>
            <param name="CopyOrMove">True для Копировать,  False для Переместить</param>
            <returns>Возвращает абсолютный путь к файлу или null, если путь не удалось создать.</returns>
        </member>
        <member name="M:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.AddFileIfNotExists(System.String,System.Boolean)">
            <summary>
            NT-Добавить файл, если не существует
            </summary>
            <param name="filePathName">Абсолютный путь к добавляемому  файлу или каталогу</param>
            <param name="CopyOrMove">True для Копировать,  False для Переместить</param>
            <returns>Возвращает строку пути к файлу или null, если путь не удалось создать.</returns>
            <remarks>Если хранилище достаточно заполнено, поиск аналогов может затянуться надолго.</remarks>
        </member>
        <member name="M:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.RemoveEmptyFolders">
            <summary>
            NT-Удалить пустые подкаталоги. Запускать дважды.
            </summary>
            <remarks>
            Функция работает только если хранилище можно изменять.
            Функция просматривает подкаталоги первого и второго уровня, удаляя пустые подкаталоги.
            ЕЕ следует запускать дважды: Сначала чтобы удалить пустые каталоги нижнего уровня, 
            потом - каталоги верхнего уровня, которые в первый раз содержали пустые каталоги нижнего уровня.
            </remarks>
        </member>
        <member name="M:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.GetStatistics">
            <summary>
            NT-Получить статистику хранилища. Это долгий процесс просмотра всех файлов Хранилища.
            </summary>
            <remarks>
            Реализовано это функцией, чтобы исключить многократное использование в неправильно спланированных циклах
            </remarks>
            
        </member>
        <member name="M:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.FindPathForFileAnalog(System.String)">
            <summary>
            NT-Вернуть абсолютный путь к файлу полного аналога или null если полный аналог не найден.
            </summary>
            <param name="srcFile">Абсолютный путь к образцовому файлу или каталогу для сравнения</param>
            <returns>Возвращает путь к полному аналогу файла или каталога, или null если полный аналог не найден.</returns>
            <remarks>
            Если хранилище достаточно заполнено, поиск аналогов может затянуться надолго.
            Аналоги каталогов сейчас ищутся только по имени, так как сравнение по контенту очень долгое и сложное и не сделано.
            </remarks>
        </member>
        <member name="M:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.FindPathForFileNew(System.String)">
            <summary>
            NT-Вернуть абсолютный путь для заново добавляемого файла или null если такой путь не найден.
            </summary>
            <param name="srcFile">Абсолютный путь к исходному файлу</param>
            <returns>Возвращает путь для заново добавляемого файла (с именем файла) или null если такой путь не найден.</returns>
            <remarks>
            Возвращаемый путь может содержать несуществующие папки. 
            В этом случае надо создать весь путь перед копированием файла.
            А то вдруг пользователь передумает, а папка уже будет создана.
            </remarks>
        </member>
        <member name="M:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.checkFolderAvailable(System.String,System.String)">
            <summary>
            RT-Проверка что каталог Хранилища пригоден для добавления в него файла 
            </summary>
            <param name="folderPath">Абсолютный путь к проверяемому каталогу</param>
            <param name="filename">Имя файла, который планируется добавить в каталог</param>
            <returns>Возвращается true, если проверка прошла успешно, false в противном случае.</returns>
        </member>
        <member name="M:MyCodeLibrary.FileStorageV2.FileStorageManagerV2.IsFolderHavePlaceNotContainsName(System.String,System.String)">
            <summary>
            NT-Проверить, что каталог имеет свободное место и не содержит каталога или файла с указанным именем
            </summary>
            <param name="folderPath">Путь к проверяемому каталогу</param>
            <param name="filename">Имя для проверки</param>
            <returns>Функция возвращает true если проверка успешна и false в противном случае.</returns>
        </member>
        <member name="T:MyCodeLibrary.Hash.Crc16CcittKermit">
            <summary>
            NT-Статическая версия CRC16
            </summary>
            <example>
            sample:
            ushort crc = Crc16CcittKermit.ComputeChecksum( 0xFC, 0x05, 0x11 );
            byte[] crcBuffer = Crc16CcittKermit.ComputeChecksumBytes( 0xFC, 0x05, 0x11 );
            // crc = 0x5627
            // crcBuffer = { 0x27, 0x56 }
            </example>
        </member>
        <member name="M:MyCodeLibrary.Hash.Crc16CcittKermit.ComputeChecksum(System.Byte[])">
            <summary>
            NT-Compute checksum
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.Hash.Crc16CcittKermit.ComputeChecksumBytes(System.Byte[])">
            <summary>
            NT-Compute checksum
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.Hash.Crc16CcittKermit.ComputeChecksum(System.String,System.Text.Encoding)">
            <summary>
            NT-Compute checksum
            </summary>
            <param name="text">Text string</param>
            <param name="encoding">Text Encoding</param>
            <returns></returns>
        </member>
        <member name="T:MyCodeLibrary.Hash.Crc16">
            <summary>
            NT-Динамическая версия CRC16
            </summary>
        </member>
        <member name="M:MyCodeLibrary.Hash.Crc16.ComputeChecksum(System.Byte[])">
            <summary>
            NT-Compute checksum
            </summary>
            <param name="bytes"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.Hash.Crc16.ComputeChecksumBytes(System.Byte[])">
            <summary>
            Get bytes of CRC16
            </summary>
            <param name="bytes"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.Hash.Crc16.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:MyCodeLibrary.Hash.Crc32s">
            <summary>
            Статическая версия вычисления CRC32
            </summary>
            <remarks>
            Эта версия имеет большую таблицу полиномов.
            Зато работает из любого места кода.
            </remarks>
        </member>
        <member name="M:MyCodeLibrary.Hash.Crc32s.ComputeChecksum(System.Byte[])">
            <summary>
            Вычислить CRC32
            </summary>
            <param name="bytes">Исходные данные</param>
            <returns>Значение CRC32</returns>
        </member>
        <member name="M:MyCodeLibrary.Hash.Crc32s.ComputeChecksum(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Вычислить CRC32
            </summary>
            <param name="bytes">Исходные данные</param>
            <returns>Значение CRC32</returns>
        </member>
        <member name="M:MyCodeLibrary.Hash.Crc32s.ComputeChecksumBytes(System.Byte[])">
            <summary>
            Вычислить CRC32
            </summary>
            <param name="bytes">Исходные данные</param>
            <returns>Значение CRC32 как массив байт</returns>
        </member>
        <member name="T:MyCodeLibrary.Hash.Crc32">
            <summary>
            Вычисление контрольной суммы через объект класса
            </summary>
            <remarks>
            Таблица полинома создается конструктором при создании объекта. 
            Этот способ не подходит если расчет ведется локально.
            Зато таблица не занимает место в образе исполняемого файла.
            </remarks>
        </member>
        <member name="F:MyCodeLibrary.Hash.Crc32.table">
            <summary>
            CRC polinomial table
            </summary>
        </member>
        <member name="M:MyCodeLibrary.Hash.Crc32.#ctor">
            <summary>
            Class constructor
            </summary>
        </member>
        <member name="M:MyCodeLibrary.Hash.Crc32.ComputeChecksum(System.Byte[])">
            <summary>
            Вычислить CRC32
            </summary>
            <param name="bytes">Исходные данные</param>
            <returns>Значение CRC32</returns>
        </member>
        <member name="M:MyCodeLibrary.Hash.Crc32.ComputeChecksumBytes(System.Byte[])">
            <summary>
            Вычислить CRC32
            </summary>
            <param name="bytes">Исходные данные</param>
            <returns>Значение CRC32 как массив байт</returns>
        </member>
        <member name="T:MyCodeLibrary.Hash.CRC32st">
            <summary>
            Вычисление контрольной суммы со статической таблицей полинома.
            Работает с потоками.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.Hash.CRC32st.m_crc">
            <summary>
            The crc data checksum so far.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.Hash.CRC32st.m_totalBytesRead">
            <summary>
            Count of processed bytes when stream reading.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.Hash.CRC32st.Value">
            <summary>
            Returns the CRC32 data checksum computed so far.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.Hash.CRC32st.TotalBytesRead">
            <summary>
             Count of processed bytes when stream reading. 
             Indicates the total number of bytes applied to the CRC.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.Hash.CRC32st.Reset">
            <summary>
            Resets the CRC32 data checksum as if no update was ever called.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.Hash.CRC32st.Update(System.Int32)">
            <summary>
            Updates the checksum with the int bval.
            </summary>
            <param name = "value">
            the byte is taken as the lower 8 bits of value
            </param>
        </member>
        <member name="M:MyCodeLibrary.Hash.CRC32st.Update(System.Byte[])">
            <summary>
            Updates the checksum with the bytes taken from the array.
            </summary>
            <param name="buffer">
            buffer an array of bytes
            </param>
        </member>
        <member name="M:MyCodeLibrary.Hash.CRC32st.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Adds the byte array to the data checksum.
            </summary>
            <param name = "buffer">
            The buffer which contains the data
            </param>
            <param name = "offset">
            The offset in the buffer where the data starts
            </param>
            <param name = "count">
            The number of data bytes to update the CRC with.
            </param>
        </member>
        <member name="M:MyCodeLibrary.Hash.CRC32st.GetCrc32AndCopy(System.IO.Stream,System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream, and writes the input into the
            output stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <param name="output">The stream into which to deflate the input.</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:MyCodeLibrary.Hash.CRC32st.GetCrc32(System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="T:MyCodeLibrary.Hash.MD5Hash">
            <summary>
            Все для вычисления контрольной суммы
            </summary>
        </member>
        <member name="M:MyCodeLibrary.Hash.MD5Hash.Hash(System.Byte[])">
            <summary>
            Вычислить контрольную сумму
            </summary>
            <param name="data">Массив байт</param>
            <returns>Возвращает контрольную сумму как массив байт.</returns>
        </member>
        <member name="M:MyCodeLibrary.Hash.MD5Hash.HashS(System.Byte[])">
            <summary>
            Вычислить контрольную сумму
            </summary>
            <param name="data">Массив байт</param>
            <returns>Возвращает контрольную сумму как шестнадцатиричную строку </returns>
        </member>
        <member name="M:MyCodeLibrary.Hash.MD5Hash.HashS(System.String)">
            <summary>
            Вычислить контрольную сумму
            </summary>
            <param name="text">Текст</param>
            <returns>Возвращает контрольную сумму как шестнадцатиричную строку</returns>
        </member>
        <member name="M:MyCodeLibrary.Hash.MD5Hash.StringToBytes(System.String)">
            <summary>
            Конвертировать текст в массив байт
            </summary>
            <param name="text">Строка текста</param>
            <returns>Возвращает массив байт</returns>
        </member>
        <member name="M:MyCodeLibrary.Hash.MD5Hash.BytesToString(System.Byte[])">
            <summary>
            Конвертировать массив байт в текст
            </summary>
            <param name="data">Массив байт</param>
            <returns>Строка текста</returns>
        </member>
        <member name="M:MyCodeLibrary.Hash.MD5Hash.ToHexString(System.Byte[])">
            <summary>
            Конвертировать массив байт в шестнадцатиричную строку
            </summary>
            <param name="data">Массив байт</param>
            <returns>Шестнадцатиричная строка длиной две длины входного массива.</returns>
        </member>
        <member name="T:MyCodeLibrary.Hash.FileHashes">
            <summary>
            Returns hashs of the specified files.
            </summary>
        </member>
        <member name="T:MyCodeLibrary.Hash.FileHashes.HashType">
            <summary>
            HashType
            </summary>
        </member>
        <member name="F:MyCodeLibrary.Hash.FileHashes.HashType.MD5">
            <summary>
            MD5
            </summary>
        </member>
        <member name="F:MyCodeLibrary.Hash.FileHashes.HashType.SHA1">
            <summary>
            SHA1
            </summary>
        </member>
        <member name="M:MyCodeLibrary.Hash.FileHashes.getFileHash(MyCodeLibrary.Hash.FileHashes.HashType,System.String)">
             <summary>
             Read the file and calculate the checksum
            </summary>
             <param name="type">the hash type to use</param>
             <param name="fileName">the file to read</param>
             <returns>the hex representation of the hash using uppercase chars</returns>
        </member>
        <member name="T:MyCodeLibrary.Hash.PasswordHashes">
            <summary>
            Tools to work with passwords
            </summary>
        </member>
        <member name="M:MyCodeLibrary.Hash.PasswordHashes.CreateSalt(System.Int32)">
            <summary>
            Creates a RNG Salt
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.Hash.PasswordHashes.CreateHash(System.String,System.String)">
            <summary>
            Creates a SHA512 Hash
            </summary>
            <param name="value"></param>
            <param name="salt"></param>
            <returns></returns>
        </member>
        <member name="T:MyCodeLibrary.Hash.RSAHashes">
            <summary>
            NR-Public-Private ciphering wrong
            </summary>
        </member>
        <member name="T:MyCodeLibrary.Hash.RSAHashes.RSAKeyPair">
            <summary>
            Creates an object to store an RSA Private Key and Public Key
            </summary>
        </member>
        <member name="P:MyCodeLibrary.Hash.RSAHashes.RSAKeyPair.Private">
            <summary>
            Private Key
            </summary>
        </member>
        <member name="P:MyCodeLibrary.Hash.RSAHashes.RSAKeyPair.Public">
            <summary>
            Public Key
            </summary>
        </member>
        <member name="M:MyCodeLibrary.Hash.RSAHashes.GenerateRSAKeyPair">
            <summary>
            Creates a RSA key pair
            </summary>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.Hash.RSAHashes.Encrypt(System.String,System.String)">
            <summary>
            Encrypts a string with RSA encryption
            </summary>
            <param name="publicKey"></param>
            <param name="unencryptedText"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.Hash.RSAHashes.Decrypt(System.String,System.String)">
            <summary>
            Decrypts a string with RSA encryption
            </summary>
            <param name="privateKey"></param>
            <param name="encryptedText"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:MyCodeLibrary.MyIniFileBase" -->
        <member name="F:MyCodeLibrary.MyIniFileBase.m_iniFilePathname">
            <summary>
            Путь к текущему файлу настроек
            </summary>
        </member>
        <member name="F:MyCodeLibrary.MyIniFileBase.m_lines">
            <summary>
            Список строк файла настроек
            </summary>
        </member>
        <member name="F:MyCodeLibrary.MyIniFileBase.m_Encoding">
            <summary>
            Кодировка файла настроек
            </summary>
        </member>
        <member name="P:MyCodeLibrary.MyIniFileBase.IniFilePathname">
            <summary>
            Путь к текущему файлу настроек
            </summary>
        </member>
        <member name="P:MyCodeLibrary.MyIniFileBase.Encoding">
            <summary>
            Кодировка файла настроек
            </summary>
        </member>
        <member name="M:MyCodeLibrary.MyIniFileBase.AddParameter(System.String,System.String)">
            <summary>
            NT-Добавить строку параметра в конец списка строк
            </summary>
            <param name="paramName">Имя параметра</param>
            <param name="value">Значение параметра</param>
            <remarks>
            Функция добавляет строку параметра в конец списка строк.
            Если параметр не имеет значения, передать в value пустую строку.
            </remarks>
        </member>
        <member name="M:MyCodeLibrary.MyIniFileBase.AddComment(System.String)">
            <summary>
            NT-Добавить строку комментария или пустую строку в конец списка строк
            </summary>
            <param name="value">Значение параметра</param>
        </member>
        <member name="M:MyCodeLibrary.MyIniFileBase.AddRules">
            <summary>
            NT-Добавить в файл правила его формата.
            Это важная часть файла настроек, рекомендуется всегда выводить ее в создаваемый заново файл в начале, после информации о приложении.
            Важно: Кодировка файла уже должна быть установлена!
            </summary>
        </member>
        <member name="M:MyCodeLibrary.MyIniFileBase.Clear">
            <summary>
            NT-Очистить список строк
            </summary>
        </member>
        <member name="M:MyCodeLibrary.MyIniFileBase.Save">
            <summary>
            NT-Сохранить данные в ранее указанном файле и указанной кодировке
            Если указанный файл существует, он будет перезаписан.
            Если указанный файл не существуе
            </summary>
        </member>
        <member name="M:MyCodeLibrary.MyIniFileBase.Load(System.String,System.Text.Encoding)">
            <summary>
            NT-Прочитать файл и вернуть true если файл прочитан успешно
            Исключения не выбрасываются.
            Список строк не очищается и содержит ранее добавленные строки.
            </summary>
            <param name="filename">Полный путь к файлу настроек</param>
            <param name="enc">Кодировка файла настроек</param>
            <returns>
            Если функция вернула false, значит произошло исключение.
            Ошибка: Файл настроек недоступен или отсутствует или имеет неправильный формат.
            </returns>
        </member>
        <member name="M:MyCodeLibrary.MyIniFileBase.getValue(System.String,System.StringComparison)">
            <summary>
            NT-Получить одно значение параметра
            </summary>
            <param name="parameterName">Название параметра</param>
            <param name="comp">Способ сравнения названий</param>
            <returns>Возвращается одно значение параметра.
            Если параметров с таким значением несколько, возвращается первый из них.
            Если ничего не найдено, возвращается null.
            </returns>
            
        </member>
        <member name="M:MyCodeLibrary.MyIniFileBase.getValues(System.String,System.StringComparison)">
            <summary>
            NT-Получить все значения параметра
            </summary>
            <param name="parameterName">Название параметра</param>
            <param name="comp">Способ сравнения названий</param>
            <returns>
            Возвращается список значений параметра.
            Если нет такого параметра, возвращается пустой список.
            </returns>
        </member>
        <member name="M:MyCodeLibrary.MyIniFileBase.getParameterNames">
            <summary>
            NT-Получить список названий всех параметров из файла, без самих значений.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.MyIniFileBase.isParameterExists(System.String,System.StringComparison)">
            <summary>
            NT-Проверить что параметр с таким названием существует
            </summary>
            <param name="parameterName">Название параметра</param>
            <param name="comp">Способ сравнения названий</param>
            <returns></returns>
        </member>
        <member name="T:MyCodeLibrary.RowType">
            <summary>
            Тип строки: комментарий или данные
            </summary>
        </member>
        <member name="T:MyCodeLibrary.MyIniFileRow">
            <summary>
            Представляет строку файла настроек
            </summary>
            <remarks>
            Нужен только для того, чтобы искать требуемый параметр в общем списке строк
            </remarks>
        </member>
        <member name="F:MyCodeLibrary.MyIniFileRow.m_Name">
            <summary>
            Название параметра
            </summary>
        </member>
        <member name="F:MyCodeLibrary.MyIniFileRow.m_Value">
            <summary>
            Значение параметра
            </summary>
        </member>
        <member name="F:MyCodeLibrary.MyIniFileRow.m_Type">
            <summary>
            Тип строки файла: комментарий или данные
            </summary>
        </member>
        <member name="M:MyCodeLibrary.MyIniFileRow.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MyCodeLibrary.MyIniFileRow.#ctor(System.String,System.String)">
            <summary>
            Конструктор для параметра
            </summary>
            <param name="Name"></param>
            <param name="Value"></param>
        </member>
        <member name="M:MyCodeLibrary.MyIniFileRow.#ctor(System.String)">
            <summary>
            Конструктор для комментария или пустой строки
            </summary>
            <param name="Value"></param>
        </member>
        <member name="T:MyCodeLibrary.CSetProcessor">
            <summary>
            Дополнительные функции для коллекций, множеств, массивов, списков
            </summary>
        </member>
        <member name="T:MyCodeLibrary.SimpleCache">
            <summary>
            NT- Плохой класс кеша пар Int32-String. 
            Когда коллекция переполнилась, он ее просто очищает и все заново можно заполнять.
            Это применялось для кеширования запросов БД для получения имени пользователя по ид пользователя.
            И на размере кэша 1 млн и 5000 запросов в секунду это было вполне успешно.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SimpleCache.m_maxSize">
            <summary>
            Максимальный размер кеша
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SimpleCache.m_Dictionary">
            <summary>
            словарь-хранилище данных
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SimpleCache.m_rnd">
            <summary>
            генератор случайных чисел для удаления элементов словаря
            </summary>
        </member>
        <member name="M:MyCodeLibrary.SimpleCache.#ctor">
            <summary>
            Конструктор
            </summary>
        </member>
        <member name="M:MyCodeLibrary.SimpleCache.#ctor(System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="size">Максимальный размер кеша</param>
        </member>
        <member name="P:MyCodeLibrary.SimpleCache.MaxSize">
            <summary>
            Максимальный размер кеша
            </summary>
        </member>
        <member name="M:MyCodeLibrary.SimpleCache.Get(System.Int32)">
            <summary>
            NT-Получить значение по идентификатору элемента
            </summary>
            <param name="userId"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.SimpleCache.IsExists(System.Int32)">
            <summary>
            NT- Возвращает true если коллекция содержит указанный элемент
            </summary>
            <param name="userId">Идентификатор элемента</param>
            <returns></returns>
        </member>
        <member name="F:MyCodeLibrary.HTMLoperations.HTMLprocessor.htmlCharReplaces">
            <summary>
            Массив строк html-кодов и их текстовых замен.
            </summary>
            <remarks>
            Текстовая замена должна состоять из ASCII символов
            </remarks>
        </member>
        <member name="M:MyCodeLibrary.HTMLoperations.HTMLprocessor.parseTagString(System.String)">
            <summary>
            NT-Разделить строку тегов из Posts на отдельные теги без скобок.
            Теги еще надо потом дообработать: .Trim().ToLowerInvariant() для гарантии.
            </summary>
            <param name="input">Строка тегов</param>
            <returns>Возвращает массив строк тегов</returns>
        </member>
        <member name="M:MyCodeLibrary.HTMLoperations.HTMLprocessor.makeTagString(System.String)">
            <summary>
            Собрать строку тегов через запятую и убрать угловые скобки
            </summary>
            <param name="tags">Строка тегов в угловых скобках</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:MyCodeLibrary.HTMLoperations.HTMLprocessor.getSafeHtmlText(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:MyCodeLibrary.HTMLoperations.HTMLprocessor.getSafeHtmlText2(System.String)" -->
        <member name="M:MyCodeLibrary.HTMLoperations.HTMLprocessor.ReplaceHtmlCharCodes(System.String)">
            <summary>
            NT-Заменить html-символы в строке на их текстовые аналоги/
            Функция очень поверхностная, нуждается в доработке/развитии.
            </summary>
            <param name="text">Входная строка</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.HTMLoperations.HTMLprocessor.tryMakeLink(System.String)">
            <summary>
            NT-попробовать собрать ссылку из этого веб-адреса
            Вернуть ссылку или исходную строку
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.HTMLoperations.HTMLprocessor.makeHtmlFileLink(System.String,System.String)">
            <summary>
            NT-Собрать веб-ссылку
            </summary>
            <param name="link">веб-ссылка или ссылка на файл</param>
            <param name="title">Название ссылки</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.HTMLoperations.HTMLprocessor.GetHtml(System.String)">
            <summary>
            Returns a string of the HTML of the specified URL String.
            </summary>
            <param name="url"></param>
        </member>
        <member name="M:MyCodeLibrary.HTMLoperations.HTMLprocessor.GetHtml(System.Uri)">
            <summary>
            Returns a string of the HTML of the specified Uri object.
            </summary>
            <param name="url"></param>
        </member>
        <member name="M:MyCodeLibrary.HTMLoperations.HTMLprocessor.GetJson(System.String,System.String)">
            <summary>
            Returns a string of the JSON request
            </summary>
            <param name="url">API URL</param>
            <param name="CurrentToken">API Security Token</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.HTMLoperations.HTMLprocessor.GetJson(System.Uri,System.String)">
            <summary>
            Returns a string of the JSON request
            </summary>
            <param name="url">API URL</param>
            <param name="currentToken">API Security Token</param>
            <returns></returns>
        </member>
        <member name="T:MyCodeLibrary.myRandom">
            <summary>
             Represents a pseudo-random number generator.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.myRandom.GetBytes(System.Byte[])">
            <summary>
             Fills the elements of a specified array of bytes with random numbers.
            </summary>
            <param name="data">An array of bytes to contain random numbers.</param>
        </member>
        <member name="M:MyCodeLibrary.myRandom.NextDouble">
            <summary>
             Returns a random number between 0.0 and 1.0.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.myRandom.Next(System.Int32,System.Int32)">
            <summary>
             Returns a random number within the specified range.
            </summary>
            <param name="minValue">The inclusive lower bound of the random number returned.</param>
            <param name="maxValue">The exclusive upper bound of the random number returned. maxValue must be greater than or equal to minValue.</param>
        </member>
        <member name="M:MyCodeLibrary.myRandom.Next">
            <summary>
             Returns a nonnegative random number.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.myRandom.Next(System.Int32)">
            <summary>
             Returns a nonnegative random number less than the specified maximum
            </summary>
            <param name="maxValue">The inclusive upper bound of the random number returned. maxValue must be greater than or equal 0</param>
        </member>
        <member name="T:MyCodeLibrary.SystemInfo.SystemInfoProcessor">
            <summary>
            Gets the different infos provides by the operating system.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.OsVersionStringLong">
            <summary>
            Return a full version String, es.: "Windows XP Service Pack 2 (32 Bit)"
            </summary>
            <returns>A String representing a fully displayable version</returns>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.OsVersionStringLong2">
            <summary>
            Return a full version String, es.: "Windows XP Service Pack 2 (32 Bit)"
            </summary>
            <returns>A String representing a fully displayable version</returns>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.OsVersionType">
            <summary>
            Returns the name of the operating system running on this Computer.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.OsVersionString">
            <summary>
            Returns the name of the operating system running on this Computer.
            </summary>
            <returns>A String containing the the operating system name.</returns>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.ComputerNameActive">
            <summary>
            Gets the current Computer name.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.ComputerNamePending">
            <summary>
            Gets the pending Computer name that it will update to on reboot.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.Is64BitOS">
             <summary>
             Identifies if OS is a 64 Bit OS
             </summary>
             <returns>True if OS is a 64 Bit OS</returns>
            
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.IsServer">
             <summary>
             Identifies if OS is a Windows Server OS
             </summary>
             <returns>True if OS is a Windows Server OS</returns>
            
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.IsDomainController">
             <summary>
             Identifies if OS is a Windows Domain Controller
             </summary>
             <returns>True if OS is a Windows Server OS</returns>
            
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.Is32BitProcessOn64BitProcessor">
             <summary>
             Identifies Arch of running process
             </summary>
             <returns>True if process is 32bit running on a 64bit machine</returns>
            
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.Win32MethodExists">
            <summary>
            The function determines whether a method exists in the export
            table of a certain module.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.IsXPOrLater">
            <summary>
            Return if running on XP or later
            </summary>
            <returns>true means XP or later</returns>
            <returns>false means 2000 or previous</returns>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.IsXP64OrLater">
            <summary>
            Return if running on XP 64 or later
            </summary>
            <returns>true means XP 64 or later</returns>
            <returns>false means XP or previous</returns>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.IsVistaOrLater">
            <summary>
            Return if running on Vista or later
            </summary>
            <returns>true means Vista or later</returns>
            <returns>false means Xp or previous</returns>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.IsWin7OrLater">
            <summary>
            Return if running on Windows7 or later
            </summary>
            <returns>true means Windows7 or later</returns>
            <returns>false means Vista or previous</returns>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.IsWin8OrLater">
            <summary>
            Return if running on Windows8 or later
            </summary>
            <returns>true means Windows8 or later</returns>
            <returns>false means Win7 or previous</returns>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.IsWin81OrLater">
            <summary>
            Return if running on Windows8.1 or later
            </summary>
            <returns>true means Windows8.1 or later</returns>
            <returns>false means Win8 or previous</returns>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.IsWin10OrLater">
            <summary>
            Return if running on Windows10 or later
            </summary>
            <returns>true means Windows10 or later</returns>
            <returns>false means Win10 or previous</returns>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.IsActivatedWMI">
            <summary>
            Checks If Windows Is Activated. Uses the newer WMI.
            </summary>
            <returns>Licensed If Genuinely Activated</returns>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.IsActivatedSLMGR">
             <summary>
             Checks If Windows Is Activated. Uses the older Software Licensing Manager Script.
             </summary>
             <returns>Licensed If Genuinely Activated</returns>
            
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.ArchitectureString">
            <summary>
            Determines if the current application is 32 or 64-bit.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.ArchitectureNumber">
            <summary>
            Determines if the current application is 32 or 64-bit.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.BiosName">
            <summary>
            Returns the full name of the system BIOS stored in the registry.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.BiosReleaseDate">
            <summary>
            Returns the system BIOS release date stored in the registry.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.BiosVersion">
            <summary>
            Returns the system BIOS version stored in the registry.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.BiosVendor">
            <summary>
            Returns the system BIOS vendor name stored in the registry.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.ProcessorName">
            <summary>
            Returns the system processor name that is stored in the registry.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.ProcessorCount">
            <summary>
            Returns the number of cores available on the system processor.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.ManufacturerName">
            <summary>
            Returns the system manufacturer name that is stored in the registry.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.ProductName">
            <summary>
            Returns the system product name that is stored in the registry.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.GetTotalRam">
            <summary>
            Returns the total ram installed on the Computer.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.InstalledDrives">
            <summary>
            Returns list of installed drives and their information
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.SystemDrive">
            <summary>
            Returns information about the drive Windows is installed on.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.SystemDrivePath">
            <summary>
            NT-
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.SystemDriveSizeString">
            <summary>
            Returns the drive size of the drive Windows is installed on.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.SystemDriveFreeSpaceString">
            <summary>
            Returns the free space of drive of the drive Windows is installed on.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.RegisteredOrganization">
            <summary>
            Gets the current Registered Organization.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.RegisteredOwner">
            <summary>
            Gets the current Registered Owner.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.LoggedInUserName">
            <summary>
            Gets the user name of the person who is currently logged on to the Windows operating system.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.CurrentDomainName">
            <summary>
            Gets the network domain name associated with the current user.
            </summary>
            <exception cref="T:System.PlatformNotSupportedException">The operating system does not support retrieving the network domain name.</exception>
            <exception cref="T:System.InvalidOperationException">The network domain name cannot be retrieved.</exception>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.OsEditionString">
            <summary>
            NT-Returns the product type of the operating system running on this Computer.
            </summary>
            <returns>A String containing the the operating system product type.</returns>
        </member>
        <member name="M:MyCodeLibrary.SystemInfo.SystemInfoProcessor.editionGetVersion5">
            <summary>
            NT-Returns the product type from Windows 2000 to XP and Server 2000 to 2003
            </summary>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.SystemInfo.SystemInfoProcessor.editionGetVersion6More">
            <summary>
            NT-Returns the product type from Windows Vista to 10 and Server 2008 to 2016
            </summary>
            <returns></returns>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.OsProductType">
            <summary>
            NT-Gets the product type of the operating system running on this Computer.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.SystemInfo.SystemInfoProcessor.getProductInfo">
            <summary>
            NR-
            </summary>
            <returns></returns>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.OsProductKey">
             <summary>
             Gets And Decrypts The Current Product Key From The Registry
             </summary>
             <returns>Returns Product Key As A String</returns>
            
        </member>
        <member name="M:MyCodeLibrary.SystemInfo.SystemInfoProcessor.DecodeOsProductKeyWin7AndBelow(System.Byte[])">
            <summary>
            Returns the decoded product key from the provided byte array. Works with Windows 7 and below.
            </summary>
            <param name="digitalProductId"></param>
        </member>
        <member name="M:MyCodeLibrary.SystemInfo.SystemInfoProcessor.DecodeOsProductKeyWin8AndUp(System.Byte[])">
            <summary>
            Returns the decoded product key from the provided byte array. Works with Windows 8 and up.
            </summary>
            <param name="digitalProductId"></param>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.OsServicePackString">
             <summary>
             Returns the service pack information of the operating system running on this Computer.
             </summary>
             <returns>A String containing the operating system service pack inFormation.</returns>
            
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.SystemInfoProcessor.OsServicePackNumber">
             <summary>
             Returns the service pack information of the operating system running on this Computer.
             </summary>
             <returns>A int containing the operating system service pack number.</returns>
            
        </member>
        <member name="T:MyCodeLibrary.SystemInfo.OsType">
            <summary>
            List of all operating systems
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.OsType.Windows2000AndPrevious">
            <summary>
             Windows 95/98, NT4.0, 2000
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.OsType.WindowsXP">
            <summary>
             Windows XP x86
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.OsType.WindowsXP64">
            <summary>
             Windows XP x64
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.OsType.WindowsVista">
            <summary>
             Windows Vista
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.OsType.Windows7">
            <summary>
             Windows 7
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.OsType.Windows8">
            <summary>
             Windows 8
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.OsType.Windows81">
            <summary>
             Windows 8
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.OsType.Windows10">
            <summary>
             Windows 10
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.OsType.Windows2003">
            <summary>
             Windows 2003 Server
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.OsType.Windows2003R2">
            <summary>
             Windows 2003 R2 Server
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.OsType.Windows2008">
            <summary>
             Windows 2008 Server
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.OsType.Windows2008R2">
            <summary>
             Windows 2008 R2 Server
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.OsType.Windows2012">
            <summary>
             Windows 2012 Server
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.OsType.Windows2012R2">
            <summary>
             Windows 2012 R2 Server
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.OsType.Windows2016">
            <summary>
             Windows 2016 Server
            </summary>
        </member>
        <member name="T:MyCodeLibrary.SystemInfo.ProductType">
            <summary>
            A list of Product Types according to ( http://msdn.microsoft.com/en-us/library/ms724833(VS.85).aspx )
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductType.NTWorkstation">
            <summary>
            Workstation
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductType.NTDomainController">
            <summary>
            Domain Controller
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductType.NTServer">
            <summary>
            Server
            </summary>
        </member>
        <member name="T:MyCodeLibrary.SystemInfo.ProductEditionEnum">
            <summary>
            General constants
            </summary>
            <summary>
            A list of Product Editions according to ( http://msdn.microsoft.com/en-us/library/ms724358(VS.85).aspx )
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.Business">
            <summary>
            Business
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.BusinessN">
            <summary>
            BusinessN
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.ClusterServer">
            <summary>
            ClusterServer
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.DatacenterServer">
            <summary>
            DatacenterServer
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.DatacenterServerCore">
            <summary>
            DatacenterServerCore
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.DatacenterServerCoreV">
            <summary>
            DatacenterServerCoreV
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.DatacenterServerV">
            <summary>
            DatacenterServerV
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.Enterprise">
            <summary>
            Enterprise
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.EnterpriseE">
            <summary>
            EnterpriseE
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.EnterpriseN">
            <summary>
            EnterpriseN
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.EnterpriseServer">
            <summary>
            EnterpriseServer
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.EnterpriseServerCore">
            <summary>
            EnterpriseServerCore
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.EnterpriseServerCoreV">
            <summary>
            EnterpriseServerCoreV
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.EnterpriseServerIA64">
            <summary>
            EnterpriseServerIA64
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.EnterpriseServerV">
            <summary>
            EnterpriseServerV
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.HomeBasic">
            <summary>
            HomeBasic
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.HomeBasicE">
            <summary>
            HomeBasicE
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.HomeBasicN">
            <summary>
            HomeBasicN
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.HomePremium">
            <summary>
            HomePremium
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.HomePremiumE">
            <summary>
            HomePremiumE
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.HomePremiumN">
            <summary>
            HomePremiumN
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.MediumBusinessServerManagement">
            <summary>
            MediumBusinessServerManagement
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.MediumBusinessServerMessaging">
            <summary>
            MediumBusinessServerMessaging
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.MediumBusinessServerSecurity">
            <summary>
            MediumBusinessServerSecurity
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.Professional">
            <summary>
            Professional
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.ProfessionalE">
            <summary>
            ProfessionalE
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.ProfessionalN">
            <summary>
            ProfessionalN
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.ServerForSmallBusiness">
            <summary>
            ServerForSmallBusiness
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.ServerForSmallBusinessV">
            <summary>
            ServerForSmallBusinessV
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.SmallBusinessServer">
            <summary>
            SmallBusinessServer
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.StandardServer">
            <summary>
            StandardServer
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.StandardServerCore">
            <summary>
            StandardServerCore
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.StandardServerCoreV">
            <summary>
            StandardServerCoreV
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.StandardServerV">
            <summary>
            StandardServerV
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.Starter">
            <summary>
            Starter
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.StarterE">
            <summary>
            StarterE
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.StarterN">
            <summary>
            StarterN
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.StorageEnterpriseServer">
            <summary>
            StorageEnterpriseServer
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.StorageExpressServer">
            <summary>
            StorageExpressServer
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.StorageStandardServer">
            <summary>
            StorageStandardServer
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.StorageWorkgroupServer">
            <summary>
            StorageWorkgroupServer
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.Undefined">
            <summary>
            Undefined
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.Ultimate">
            <summary>
            Ultimate
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.UltimateE">
            <summary>
            UltimateE
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.UltimateN">
            <summary>
            UltimateN
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.WebServer">
            <summary>
            WebServer
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.ProductEditionEnum.WebServerCore">
            <summary>
            WebServerCore
            </summary>
        </member>
        <member name="T:MyCodeLibrary.SystemInfo.VERSuite">
            <summary>
            A list of Version Suite Masks according to ( http://msdn.microsoft.com/en-us/library/ms724833(VS.85).aspx )
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.VERSuite.Enterprise">
            <summary>
            Enterprise
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.VERSuite.EmbeddedNT">
            <summary>
            EmbeddedNT
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.VERSuite.Datacenter">
            <summary>
            Datacenter
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.VERSuite.Personal">
            <summary>
            Personal
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.VERSuite.Blade">
            <summary>
            Blade
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.VERSuite.StorageServer">
            <summary>
            StorageServer
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SystemInfo.VERSuite.ComputeServer">
            <summary>
            ComputeServer
            </summary>
        </member>
        <member name="T:MyCodeLibrary.SystemInfo.myOsVersionInfo">
            <summary>
            NT-Класс версии ОС с получением данных через WMI
            </summary>
        </member>
        <member name="M:MyCodeLibrary.SystemInfo.myOsVersionInfo.get_Main">
            <summary>
            Gets the full version of the operating system running on this Computer. Uses the newer WMI.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.SystemInfo.myOsVersionInfo.get_Major">
            <summary>
            Gets the major version of the operating system running on this Computer. Uses the newer WMI.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.SystemInfo.myOsVersionInfo.get_Minor">
            <summary>
            Gets the minor version of the operating system running on this Computer. Uses the newer WMI.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.SystemInfo.myOsVersionInfo.get_Build">
            <summary>
            Gets the build version of the operating system running on this Computer. Uses the newer WMI.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.SystemInfo.myOsVersionInfo.get_Revision">
            <summary>
            Gets the revision version of the operating system running on this Computer. Uses the newer WMI.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.SystemInfo.myOsVersionInfo.get_Number">
            <summary>
            Return a numeric value representing OS version. Uses the newer WMI.
            </summary>
            <returns>(OSMajorVersion * 10 + OSMinorVersion)</returns>
        </member>
        <member name="M:MyCodeLibrary.SystemInfo.myOsVersionInfo.GetVersionInfo(MyCodeLibrary.SystemInfo.myOsVersionInfo.VersionRequestType)">
            <summary>
            NT-Get OS version info from WMI
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:MyCodeLibrary.SystemInfo.myOsVersionInfo.VersionRequestType">
            <summary>
            NT-типы запрашиваемых значений
            </summary>
        </member>
        <member name="T:MyCodeLibrary.SystemInfo.myOsVersionInfoBase">
            <summary>
            NT-Класс версии ОС с получением данных через Environment.OSVersion
            </summary>
            <remarks>
            Семантическая избыточность в версиях классов версий ОС
            Взяты функции из VersionObject, Version 
            
            </remarks>
        </member>
        <member name="M:MyCodeLibrary.SystemInfo.myOsVersionInfoBase.get_Main">
             <summary>
             Gets the full version of the operating system running on this Computer. Uses the deprecated OSVersion.
             </summary>
            
        </member>
        <member name="M:MyCodeLibrary.SystemInfo.myOsVersionInfoBase.get_Major">
            <summary>
            Gets the major version of the operating system running on this Computer. Uses the deprecated OSVersion.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.SystemInfo.myOsVersionInfoBase.get_Minor">
            <summary>
            Gets the minor version of the operating system running on this Computer. Uses the deprecated OSVersion.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.SystemInfo.myOsVersionInfoBase.get_Build">
            <summary>
            Gets the build version of the operating system running on this Computer. Uses the deprecated OSVersion.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.SystemInfo.myOsVersionInfoBase.get_Revision">
            <summary>
            Gets the revision version of the operating system running on this Computer. Uses the deprecated OSVersion.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.SystemInfo.myOsVersionInfoBase.get_Number">
            <summary>
            Return a numeric value representing OS version. Uses the deprecated OSVersion.
            </summary>
            <returns>(OSMajorVersion * 10 + OSMinorVersion)</returns>
        </member>
        <member name="T:MyCodeLibrary.SystemInfo.BIOSObject">
            <summary>
            BIOS Object
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.BIOSObject.Name">
            <summary>
            BIOS Name
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.BIOSObject.ReleaseDate">
            <summary>
            BIOS Release Date
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.BIOSObject.Vendor">
            <summary>
            BIOS Vendor
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.BIOSObject.Version">
            <summary>
            BIOS Version
            </summary>
        </member>
        <member name="T:MyCodeLibrary.SystemInfo.ComputerInfoObject">
            <summary>
            Creates an object that holds info about the computer.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.SystemInfo.ComputerInfoObject.#ctor">
            <summary>
            Constructor initializes values();
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.ComputerInfoObject.Hardware">
            <summary>
            Returns information about the Computers hardware.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.ComputerInfoObject.OS">
            <summary>
            Returns information about the Computers operating system.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.SystemInfo.ComputerInfoObject.ReinitializeHardware">
            <summary>
            Initalizes the hardware class.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.SystemInfo.ComputerInfoObject.ReinitalizeOS">
            <summary>
            Initalizes the software class.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MyCodeLibrary.SystemInfo.DriveObject">
            <summary>
            Drive Object
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.DriveObject.Name">
            <summary>
            Drive Name
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.DriveObject.Format">
            <summary>
            Drive Format
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.DriveObject.Label">
            <summary>
            Drive Label
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.DriveObject.DriveType">
            <summary>
            Drive Type
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.DriveObject.TotalSize">
            <summary>
            Drive Total Size
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.DriveObject.TotalFree">
            <summary>
            Drive Total Free Space
            </summary>
        </member>
        <member name="T:MyCodeLibrary.SystemInfo.HWObject">
            <summary>
            Hardware Data Objects
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.HWObject.SystemOEM">
            <summary>
            System OEM
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.HWObject.ProductName">
            <summary>
            Product Name
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.HWObject.BIOS">
            <summary>
            BIOS Object
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.HWObject.Network">
            <summary>
            Network Object
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.HWObject.Processor">
            <summary>
            Processor Object
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.HWObject.RAM">
            <summary>
            RAM Object
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.HWObject.Storage">
            <summary>
            Storage Object
            </summary>
        </member>
        <member name="T:MyCodeLibrary.SystemInfo.InstallInfoObject">
            <summary>
            Install Info Object
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.InstallInfoObject.ActivationStatus">
            <summary>
            Activation Status
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.InstallInfoObject.Architecture">
            <summary>
            Architecture
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.InstallInfoObject.NameExpanded">
            <summary>
            Display Version
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.InstallInfoObject.Name">
            <summary>
            Name
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.InstallInfoObject.ProductKey">
            <summary>
            Product Key
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.InstallInfoObject.ServicePack">
            <summary>
            Service Pack
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.InstallInfoObject.ServicePackNumber">
            <summary>
            Service Pack Number
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.InstallInfoObject.Version">
            <summary>
            Version Object
            </summary>
        </member>
        <member name="T:MyCodeLibrary.SystemInfo.NetworkObject">
            <summary>
            Network Object
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.NetworkObject.InternalIPAddress">
            <summary>
            Internal IP Address
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.NetworkObject.ExternalIPAddress">
            <summary>
            External IP Address
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.NetworkObject.ConnectionStatus">
            <summary>
            Internet Connection Status
            </summary>
        </member>
        <member name="T:MyCodeLibrary.SystemInfo.OSObject">
            <summary>
            OS Object
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.OSObject.ComputerName">
            <summary>
            Computer Name
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.OSObject.ComputerNamePending">
            <summary>
            Computer Name Pending
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.OSObject.InstallInfo">
            <summary>
            Install Info Object
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.OSObject.RegisteredOrganization">
            <summary>
            Registered Organization Name
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.OSObject.RegisteredOwner">
            <summary>
            Registered Owner Name
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.OSObject.LoggedInUserName">
            <summary>
            Logged In Username
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.OSObject.DomainName">
            <summary>
            Currently Joined Domain Name
            </summary>
        </member>
        <member name="T:MyCodeLibrary.SystemInfo.ProcessorObject">
            <summary>
            Processor Object
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.ProcessorObject.Name">
            <summary>
            Processor Name
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.ProcessorObject.Cores">
            <summary>
            Number Of Processor Cores
            </summary>
        </member>
        <member name="T:MyCodeLibrary.SystemInfo.RAMObject">
            <summary>
            RAM Object
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.RAMObject.TotalInstalled">
            <summary>
            Total Installed RAM
            </summary>
        </member>
        <member name="T:MyCodeLibrary.SystemInfo.StorageObject">
            <summary>
            Storage Object
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.StorageObject.InstalledDrives">
            <summary>
            List of installed Drives
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.StorageObject.SystemDrive">
            <summary>
            System Boot Drive
            </summary>
        </member>
        <member name="T:MyCodeLibrary.SystemInfo.VersionObject">
            <summary>
            Version Object
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.VersionObject.Main">
            <summary>
            Version Main String
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.VersionObject.Major">
            <summary>
            Version Major
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.VersionObject.Minor">
            <summary>
            Version Minor
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.VersionObject.Build">
            <summary>
            Version Build
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.VersionObject.Revision">
            <summary>
            Version Revision
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SystemInfo.VersionObject.Number">
            <summary>
            Version Number
            </summary>
        </member>
        <member name="T:MyCodeLibrary.TextProcessing.BaseXCoder">
            <summary>
            Класс для кодирования и декодирования чисел в шестнадцатеричной или другой системе
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.BaseXCoder.AsciiChars">
            <summary>
            Набор символов кодера по умолчанию
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.BaseXCoder.HexChars">
            <summary>
            Набор символов кодера по умолчанию
            </summary>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.BaseXCoder.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.BaseXCoder.#ctor(System.String)">
            <summary>
            Конструктор
            </summary>
            <param name="letters">Строка символов, представляющих число</param>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.BaseXCoder.Encode(System.Int32,System.Int32)">
            <summary>
            Переводит число в строковое представление
            </summary>
            <param name="number">Конвертируемое число</param>
            <param name="length">Число требуемых символов результата, не считая знака</param>
            <returns>Возвращает строковое представление, возможно содержащее знак отрицательного числа</returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.BaseXCoder.Decode(System.String)">
            <summary>
            Переводит строковое представление в число
            </summary>
            <param name="text">Строка, буквы должны быть в правильном регистре</param>
            <returns>Возвращает число</returns>
            <exception cref="T:System.ArgumentException">Входная строка имеет неправильный формат.</exception>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.BaseXCoder.Encode2(System.Int32)">
            <summary>
            Переводит число в строковое представление из двух букв
            </summary>
            <param name="number">Положительное целое число от 0 до ХЗ</param>
            <returns>Возвращает строковое представление числа</returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.BaseXCoder.isBaseXstring(System.String,System.String)">
            <summary>
            NT-Проверка, что текст содержит только допустимые символы
            </summary>
            <param name="text">Строка текста BaseX кодировки</param>
            <param name="CodeChars">Строка символов BaseX кодировки</param>
            <returns>True если строка содержит только символы кодировки, False если содержит посторонние символы</returns>
        </member>
        <member name="T:MyCodeLibrary.TextProcessing.CStringProcessor">
            <summary>
            Различные функции текстовых строк
            </summary>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.CStringProcessor.BytesToString(System.Byte[])">
            <summary>
            RT-Конвертировать блок данных в строку
            </summary>
            <param name="bar">Конвертируемый блок данных</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.CStringProcessor.StringToBytes(System.String)">
            <summary>
            RT-Конвертировать строку в блок данных
            </summary>
            <param name="text">Конвертируемая строка</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.CStringProcessor.ToHexString(System.UInt32)">
            <summary>
            
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.CStringProcessor.FromHexString(System.String)">
            <summary>
            
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.CStringProcessor.RemoveWhiteSpaces(System.String)">
            <summary>
            NT- Удалить из строки двойные пробелы, переносы строк, TAB итп.
            </summary>
            <param name="text">Входная строка</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.CStringProcessor.IfNullOrEmpty(System.String,System.String)">
            <summary>
            	Checks if a string is null or empty and returns a default value if fails
            </summary>
            <param name = "value"></param>
            <param name = "defaultValue"></param>
            <returns>Either the string or the default value.</returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.CStringProcessor.IsNullOrEmptyOrWhiteSpace(System.String)">
            <summary>
            It returns true if string is null or empty or just a white space otherwise it returns false
            </summary>
            <param name = "input">Target reference. Can be null.</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.CStringProcessor.IsValidUrl(System.String)">
            <summary>
            Checks if a string is an valid URL
            </summary>
            <param name = "input">Target reference.</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.CStringProcessor.IsValidIPAddress(System.String)">
            <summary>
            Checks if a string is a valid IPv4 address
            </summary>
            <param name = "input">Target reference.</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.CStringProcessor.IsValidEmailAddress(System.String)">
            <summary>
            Checks if a string is an valid e-mail address
            </summary>
            <param name = "input">Target reference.</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.CStringProcessor.EnsureStartsWith(System.String,System.String,System.Boolean)">
            <summary>
            	Ensures that a string starts with a given prefix.
            </summary>
            <param name = "input"></param>
            <param name = "prefix"></param>
            <param name = "ignoreCase"></param>
            <returns>The string value including the prefix</returns>
            <example>
            	<code>
            		var extension = "txt";
            		var fileName = string.Concat(file.Name, extension.EnsureStartsWith(".", true));
            	</code>
            </example>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.CStringProcessor.EnsureEndsWith(System.String,System.String,System.Boolean)">
            <summary>
            	Ensures that a string ends with a given suffix.
            </summary>
            <param name = "input"></param>
            <param name = "suffix"></param>
            <param name = "ignoreCase"></param>
            <returns>The string value including the suffix</returns>
            <example>
            	<code>
            		var url = "http://www.google.com";
            		url = url.EnsureEndsWith("/", true));
            	</code>
            </example>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.CStringProcessor.ToBoolean(System.String)">
            <summary>
            Converts a string to a Boolean. ArgumentException is thrown if fails
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.CStringProcessor.RemoveLast(System.String,System.Int32)">
            <summary>
            Removes the last number of characters from a string
            </summary>
            <param name="input"></param>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.CStringProcessor.RemoveFirst(System.String,System.Int32)">
            <summary>
            Removes the first number of characters from a string
            </summary>
            <param name="input"></param>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.CStringProcessor.RemoveAllSpecialCharacters(System.String)">
            <summary>
            Removes all special characters from the string.
            </summary>
            <param name="input"></param>
            <returns>The adjusted string.</returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.CStringProcessor.Reverse(System.String)">
            <summary>
            	Reverses / mirrors a string.
            </summary>
            <param name = "input"></param>
            <returns>The reversed string</returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.CStringProcessor.LeftOf(System.String,System.Char)">
            <summary>
            Returns the first part of the string, up until the character c. If c is not found in the
            string the whole string is returned.
            </summary>
            <param name="input">String to truncate</param>
            <param name="c">Separator</param>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.CStringProcessor.RightOf(System.String,System.Char)">
            <summary>
            Returns right part of the string, after the character c. If c is not found in the
            string the whole string is returned.
            </summary>
            <param name="input">String to truncate</param>
            <param name="c">Separator</param>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.CStringProcessor.DoesNotStartWith(System.String,System.String)">
            <summary>
            Returns true if string does not start with the pattern, otherwise false. If patern is null or empty, false will be returned.
            </summary>
            <param name="input"></param>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.CStringProcessor.DoesNotEndWith(System.String,System.String)">
            <summary>
            Returns true if string does not end with the pattern, otherwise false. If patern is null or empty, false will be returned.
            </summary>
            <param name="input"></param>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.CStringProcessor.FirstChar(System.String)">
            <summary>
            Returns first character in a string
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.CStringProcessor.LastChar(System.String)">
            <summary>
            Returns last character in a string
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.CStringProcessor.FirstChars(System.String,System.Int32)">
            <summary>
            Returns first number of characters in string
            </summary>
            <param name="input"></param>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.CStringProcessor.UppercaseFirst(System.String)">
            <summary>
            Returns string with first char upercase
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:MyCodeLibrary.TextProcessing.UDE.CharsetDetector" -->
        <member name="F:MyCodeLibrary.TextProcessing.UDE.CharsetDetector.charset">
            <summary>
            Текстовое название кодировки
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.CharsetDetector.confidence">
            <summary>
            Уверенность определения как число в пределах 0..1
            </summary>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.CharsetDetector.#ctor">
            <summary>
            Конструктор по умолчанию
            </summary>
        </member>
        <member name="P:MyCodeLibrary.TextProcessing.UDE.CharsetDetector.Charset">
            <summary>
            Текстовое название кодировки
            </summary>
        </member>
        <member name="P:MyCodeLibrary.TextProcessing.UDE.CharsetDetector.Confidence">
            <summary>
            Уверенность определения как число в пределах 0..1
            </summary>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.CharsetDetector.Feed(System.IO.Stream)">
            <summary>
            Отправить в детектор поток текста для обработки
            </summary>
            <param name="stream">Поток, содержащий исходный текст</param>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.CharsetDetector.IsDone">
            <summary>
            Узнать, закончено ли определение кодировки
            </summary>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.CharsetDetector.Reset">
            <summary>
            Сбросить детектор в исходное состояние
            </summary>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.CharsetDetector.Report(System.String,System.Single)">
            <summary>
            Переопределите эту функцию для получения результата детектирования
            </summary>
            <param name="charset">Название кодировки как член класса Charsets</param>
            <param name="confidence">Уверенность детектора (0..1)</param>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.CharsetDetector.DetectFileEncodingString(System.String)">
            <summary>
            NT-Определить кодировку текстового файла
            </summary>
            <param name="filepath">Путь текстового файла</param>
            <returns>Функция возвращает название кодировки, либо null если кодировку определить не удалось.</returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.CharsetDetector.DetectFileEncoding(System.String)">
            <summary>
            NT-Определить кодировку текстового файла
            </summary>
            <param name="filepath">Путь текстового файла</param>
            <returns>Функция возвращает название кодировки, либо выбрасывает исключение ApplicationException, если кодировку определить не удалось.</returns>
            <exception cref="T:System.ApplicationException">Функция выбрасывает исключение, если если кодировку определить не удалось.</exception>
        </member>
        <member name="T:MyCodeLibrary.TextProcessing.UDE.Charsets">
            <summary>
            Хранит названия поддерживаемых кодировок
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.ASCII">
            <summary>
            US-ASCII
            CodePage=20127
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.UTF8">
            <summary>
            Unicode (UTF-8)
            CodePage=65001
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.UTF16_LE">
            <summary>
            Unicode
            CodePage=1200
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.UTF16_BE">
            <summary>
            Unicode (Big-Endian)
            CodePage=1201
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.UTF32_BE">
            <summary>
            Unicode (UTF-32 Big-Endian)
            CodePage=12001
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.UTF32_LE">
            <summary>
            Unicode (UTF-32)
            CodePage=12000
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.UCS4_3412">
            <summary>
            Unusual BOM (3412 order)
            CodePage=?
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.UCS4_2143">
            <summary>
            Unusual BOM (2143 order)
            CodePage=?
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.WIN1250">
            <summary>
            Central European (Windows)
            Hungarian?
            CodePage=1250
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.WIN1251">
            <summary>
            Cyrillic (Windows)
            Cyrillic (based on bulgarian and russian data)
            CodePage=1251
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.WIN1252">
            <summary>
            Western European (Windows)
            Latin-1, almost identical to ISO-8859-1
            CodePage=1252
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.WIN1253">
            <summary>
            Greek (Windows)
            Greek
            CodePage=1253
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.WIN1255">
            <summary>
            Hebrew (Windows)
            Logical hebrew (includes ISO-8859-8-I and most of x-mac-hebrew)
            CodePage=1255
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.BIG5">
            <summary>
            Chinese Traditional (Big5)
            CodePage=950
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.EUCKR">
            <summary>
            Korean (EUC)
            CodePage=51949
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.EUCJP">
            <summary>
            Japanese (EUC)
            CodePage=51932
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.EUCTW">
            <summary>
            
            CodePage=?
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.GB18030">
            <summary>
            Chinese Simplified (GB18030)
            Note: gb2312 is a subset of gb18030
            CodePage=54936
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.ISO2022_JP">
            <summary>
            Japanese (JIS)
            CodePage=50220
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.ISO2022_CN">
            <summary>
            
            CodePage=?
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.ISO2022_KR">
            <summary>
            Korean (ISO)
            CodePage=50225
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.HZ_GB_2312">
            <summary>
            Chinese Simplified (HZ)
            CodePage=52936
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.SHIFT_JIS">
            <summary>
            Japanese (Shift-JIS)
            CodePage=932
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.MAC_CYRILLIC">
            <summary>
            Cyrillic (Mac)
            CodePage=10007
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.KOI8R">
            <summary>
            Cyrillic (KOI8-R)
            CodePage=20866
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.IBM855">
            <summary>
            OEM Cyrillic
            CodePage=855
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.IBM866">
            <summary>
            Cyrillic (DOS)
            CodePage=866
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.ISO8859_2">
            <summary>
            Central European (ISO)
            East-Europe. Disabled because too similar to windows-1252 
            (latin-1). Should use tri-grams models to discriminate between
            these two charsets.
            CodePage=28592
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.ISO8859_5">
            <summary>
            Cyrillic (ISO) 
            CodePage=28595
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.ISO_8859_7">
            <summary>
            Greek (ISO)
            CodePage=28597
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.ISO8859_8">
            <summary>
            Hebrew (ISO-Visual)
            CodePage=28598
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Charsets.TIS620">
            <summary>
            Thai. This recognizer is not enabled yet. 
            
            CodePage=?
            </summary>
        </member>
        <member name="T:MyCodeLibrary.TextProcessing.UDE.Core.CharDistributionAnalyser">
            <summary>
            Base class for the Character Distribution Method, used for 
            the CJK encodings
            </summary>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.Core.CharDistributionAnalyser.GetOrder(System.Byte[],System.Int32)">
            <summary>
            we do not handle character base on its original encoding string, but 
            convert this encoding string to a number, here called order.
            This allow multiple encoding of a language to share one frequency table
            </summary>
            <param name="buf">A <see cref="T:System.Byte"/></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.Core.CharDistributionAnalyser.HandleOneChar(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Feed a character with known length 
            </summary>
            <param name="buf">A <see cref="T:System.Byte"/></param>
            <param name="offset">buf offset</param>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.Core.CharDistributionAnalyser.GetConfidence">
            <summary>
            return confidence base on received data
            </summary>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.Core.GB18030DistributionAnalyser.GetOrder(System.Byte[],System.Int32)">
            <summary>
            for GB2312 encoding, we are interested
              first  byte range: 0xb0 -- 0xfe
              second byte range: 0xa1 -- 0xfe
            no validation needed here. State machine has done that
            </summary>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.Core.EUCTWDistributionAnalyser.GetOrder(System.Byte[],System.Int32)">
            <summary>
            first  byte range: 0xc4 -- 0xfe
             second byte range: 0xa1 -- 0xfe
            no validation needed here. State machine has done that
            </summary>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.Core.EUCKRDistributionAnalyser.GetOrder(System.Byte[],System.Int32)">
            <summary>
            first  byte range: 0xb0 -- 0xfe
             second byte range: 0xa1 -- 0xfe
            no validation needed here. State machine has done that
            </summary>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.Core.BIG5DistributionAnalyser.GetOrder(System.Byte[],System.Int32)">
            <summary>
            first  byte range: 0xa4 -- 0xfe
             second byte range: 0x40 -- 0x7e , 0xa1 -- 0xfe
            no validation needed here. State machine has done that
            </summary>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.Core.SJISDistributionAnalyser.GetOrder(System.Byte[],System.Int32)">
            <summary>
            first  byte range: 0x81 -- 0x9f , 0xe0 -- 0xfe
             second byte range: 0x40 -- 0x7e,  0x81 -- oxfe
            no validation needed here. State machine has done that
            </summary>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.Core.EUCJPDistributionAnalyser.GetOrder(System.Byte[],System.Int32)">
            <summary>
            first  byte range: 0xa0 -- 0xfe
             second byte range: 0xa1 -- 0xfe
            no validation needed here. State machine has done that
            </summary>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.Core.CharsetProber.HandleData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Feed data to the prober
            </summary>
            <param name="buf">a buffer</param>
            <param name="offset">offset into buffer</param>
            <param name="len">number of bytes available into buffer</param>
            <returns>
            A <see cref="T:MyCodeLibrary.TextProcessing.UDE.Core.ProbingState"/>
            </returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.Core.CharsetProber.Reset">
            <summary>
            Reset prober state
            </summary>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.Core.CharsetProber.FilterWithoutEnglishLetters(System.Byte[],System.Int32,System.Int32)">
            <summary>
             
            </summary>
            <returns>filtered buffer</returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.Core.CharsetProber.FilterWithEnglishLetters(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Do filtering to reduce load to probers (Remove ASCII symbols, 
            collapse spaces). This filter applies to all scripts which contain 
            both English characters and upper ASCII characters.
            </summary>
            <returns>a filtered copy of the input buffer</returns>
        </member>
        <member name="T:MyCodeLibrary.TextProcessing.UDE.Core.CodingStateMachine">
            <summary>
            Parallel state machine for the Coding Scheme Method
            </summary>
        </member>
        <member name="T:MyCodeLibrary.TextProcessing.UDE.Core.HebrewProber">
            <summary>
            This prober doesn't actually recognize a language or a charset.
            It is a helper prober for the use of the Hebrew model probers
            </summary>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.Core.HebrewProber.HandleData(System.Byte[],System.Int32,System.Int32)">
             Final letter analysis for logical-visual decision.
             Look for evidence that the received buffer is either logical Hebrew or 
             visual Hebrew.
             The following cases are checked:
             1) A word longer than 1 letter, ending with a final letter. This is an 
                indication that the text is laid out "naturally" since the final letter 
                really appears at the end. +1 for logical score.
             2) A word longer than 1 letter, ending with a Non-Final letter. In normal
                Hebrew, words ending with Kaf, Mem, Nun, Pe or Tsadi, should not end with
                the Non-Final form of that letter. Exceptions to this rule are mentioned
                above in isNonFinal(). This is an indication that the text is laid out
                backwards. +1 for visual score
             3) A word longer than 1 letter, starting with a final letter. Final letters 
                should not appear at the beginning of a word. This is an indication that 
                the text is laid out backwards. +1 for visual score.
            
             The visual score and logical score are accumulated throughout the text and 
             are finally checked against each other in GetCharSetName().
             No checking for final letters in the middle of words is done since that case
             is not an indication for either Logical or Visual text.
            
             The input buffer should not contain any white spaces that are not (' ')
             or any low-ascii punctuation marks. 
        </member>
        <member name="T:MyCodeLibrary.TextProcessing.UDE.Core.MBCSGroupProber">
            <summary>
            Multi-byte charsets probers
            </summary>
        </member>
        <member name="T:MyCodeLibrary.TextProcessing.UDE.Core.SJISProber">
            <summary>
            for S-JIS encoding, observe characteristic:
            1, kana character (or hankaku?) often have hight frequency of appereance
            2, kana character often exist in group
            3, certain combination of kana is never used in japanese language
            </summary>
        </member>
        <member name="T:MyCodeLibrary.TextProcessing.UDE.Core.SMModel">
            <summary>
            State machine model
            </summary>
        </member>
        <member name="T:MyCodeLibrary.TextProcessing.UDE.Core.UniversalDetector">
            <summary>
            Класс делает всю работу по определению кодировки.
            Производный класс должен обналичить результаты работы.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.TextProcessing.UDE.Core.UniversalDetector.m_DumpToConsole">
            <summary>
            Выводить логи проберов в стандартную консоль
            </summary>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.Core.UniversalDetector.#ctor">
            <summary>
            Конструктор
            </summary>
        </member>
        <member name="P:MyCodeLibrary.TextProcessing.UDE.Core.UniversalDetector.DumpToConsole">
            <summary>
            Выводить логи проберов в стандартную консоль. По умолчанию вывод логов выключен (= false)
            </summary>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.Core.UniversalDetector.Feed(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Отправить в детектор порцию текста для обработки
            </summary>
            <param name="buf">Массив байт исходного текста</param>
            <param name="offset">Смещение от начала массива</param>
            <param name="len">Количество читаемых байт</param>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.Core.UniversalDetector.DataEnd">
            <summary>
            Сообщить детектору что больше данных нет и надо принять решение 
            </summary>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.Core.UniversalDetector.Reset">
            <summary>
            Сбросить состояние детектора 
            </summary>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.Core.UniversalDetector.Report(System.String,System.Single)">
            <summary>
            Переопределите эту функцию для получения результата детектирования
            </summary>
            <param name="charset">Название кодировки как член класса Charsets</param>
            <param name="confidence">Уверенность детектора (0..1)</param>
        </member>
        <member name="P:MyCodeLibrary.TextProcessing.UDE.ICharsetDetector.Charset">
            <summary>
            The detected charset. It can be null.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.TextProcessing.UDE.ICharsetDetector.Confidence">
            <summary>
            The confidence of the detected charset, if any 
            </summary>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.ICharsetDetector.Feed(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Feed a block of bytes to the detector. 
            </summary>
            <param name="buf">input buffer</param>
            <param name="offset">offset into buffer</param>
            <param name="len">number of available bytes</param>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.ICharsetDetector.Feed(System.IO.Stream)">
            <summary>
            Feed a bytes stream to the detector. 
            </summary>
            <param name="stream">an input stream</param>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.ICharsetDetector.Reset">
            <summary>
            Resets the state of the detector. 
            </summary>        
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.ICharsetDetector.IsDone">
            <summary>
            Returns true if the detector has found a result and it is sure about it.
            </summary>
            <returns>true if the detector has detected the encoding</returns>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.UDE.ICharsetDetector.DataEnd">
            <summary>
            Tell the detector that there is no more data and it must take its
            decision.
            </summary>
        </member>
        <member name="T:MyCodeLibrary.TextProcessing.Utf8FileEncodingDetector">
            <summary>
            Определять кодировку текстового файла: UTF-8 или windows-1251
            </summary>
        </member>
        <member name="M:MyCodeLibrary.TextProcessing.Utf8FileEncodingDetector.getFileEncoding(System.String)">
            <summary>
            NFT- детектор кодировки: win1251 или UTF-8
            </summary>
            <param name="filepath"></param>
            <returns></returns>
            <remarks>
            Символы в UTF-8 кодируются последовательностями длиной от 1 до 4 байт (октетов).
            Вот в таком формате:
            U+000000-U+00007F: 0xxxxxxx (ANSI)
            U+000080-U+0007FF: 110xxxxx 10xxxxxx (сюда входит кириллица)
            U+000800-U+00FFFF: 1110xxxx 10xxxxxx 10xxxxxx
            U+010000-U+10FFFF: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
            По маске первого октета определяется общее число октет в последовательности, 
            а затем они проверяются на соответствие маске 10xxxxxx. 
            Если какой-то байт не соответствует маске, значит кодировка отличная от UTF-8 (в моем случае win1251).
            Код, конечно, громоздкий, но для демонстрации самого алгоритма вполне достаточный
            </remarks>
            <example>
            <code>
            //работало на первом тесте
            Encoding e1 = Utf8Detector.getFileEncoding("C:\\Temp\\pitest.xml");
            Encoding e2 = Utf8Detector.getFileEncoding("C:\\Temp\\test.txt");
            </code>
            </example>
        </member>
        <member name="M:MyCodeLibrary.CTimeProcessor.FromUnixTimestamp(System.Int64)">
            <summary>
            Converts Unix timestamp to a DateTime
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CTimeProcessor.FromUnixTimestampUltra(System.Int64)">
            <summary>
            Converts Unix timestamp to a miliseconds DateTime
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CTimeProcessor.ToUnixTimestamp(System.DateTime)">
            <summary>
            Converts a DateTime to a Unix timestamp
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CTimeProcessor.ToUnixTimestampUltra(System.DateTime)">
            <summary>
            Converts a miliseconds DateTime to a Unix timestamp
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CTimeProcessor.IsDate(System.String)">
            <summary>
            Checks if a string is DateTime.
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CTimeProcessor.IsBefore(System.DateTime,System.DateTime)">
            <summary>
            Checks if a date falls before a date
            </summary>
            <param name="input"></param>
            <param name="from"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CTimeProcessor.IsBeforeNow(System.DateTime)">
            <summary>
            Checks if a date falls before DateTime.Now
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CTimeProcessor.IsAfter(System.DateTime,System.DateTime)">
            <summary>
            Checks if a date falls after a date
            </summary>
            <param name="input"></param>
            <param name="from"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CTimeProcessor.IsAfterNow(System.DateTime)">
            <summary>
            Checks if a date falls after DateTime.Now
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CTimeProcessor.IsToday(System.DateTime)">
            <summary>
            	Checks if a date is today.
            </summary>
            <param name = "input"></param>
            <returns>
            	<c>true</c> if the specified date is today; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:MyCodeLibrary.CTimeProcessor.IsTimeEqual(System.DateTime,System.DateTime)">
            <summary>
            	Checks if the time only part of two DateTime values are equal.
            </summary>
            <param name = "input"></param>
            <param name = "timeToCompare"></param>
            <returns>
            	<c>true</c> if both time values are equal; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="P:MyCodeLibrary.CTimeProcessor.CurrentShortTimeStamp">
            <summary>
            NR-Returns current timestamp
            </summary>
        </member>
        <member name="P:MyCodeLibrary.CTimeProcessor.CurrentFullTimeStamp">
            <summary>
            NR-Returns current timestamp extended
            </summary>
        </member>
        <member name="T:MyCodeLibrary.CWindowProcessor">
            <summary>
            Класс реализует операции с окнами
            </summary>
        </member>
        <member name="M:MyCodeLibrary.CWindowProcessor.СвернутьВсеОкна">
            <summary>
            NT-Свернуть все окна и показать рабочий стол.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.CWindowProcessor.РазвернутьВсеОкна">
            <summary>
            NT-Развернуть все окна на рабочий стол.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.CWindowProcessor.DisableConsoleCloseButton">
            <summary>
            Выключить кнопку Close на титлебаре окна консольного приложения
            </summary>
            <remarks>
            Это выключает кнопку c крестиком в заголовке окна, и пункт системного меню.
            </remarks>
        </member>
        <member name="T:MyCodeLibrary.GlobalHotkey">
            <summary>
            Обертка для глобальных хоткеев.
            </summary>
            <remarks>
            Глобальный хоткей это комбинация клавиш, которая регистрируется 
            для существующего окна приложения и позволяет вызвать его код в любой момент времени.
            Обычно для показа окна пользователю, но можно и другие действия назначить.
            Хоткей можно установить только для собственного окна текущего потока приложения. 
            </remarks>
        </member>
        <member name="F:MyCodeLibrary.GlobalHotkey.MOD_ALT">
            <summary>
            Модификатор клавиша Alt
            </summary>
        </member>
        <member name="F:MyCodeLibrary.GlobalHotkey.MOD_CONTROL">
            <summary>
            Модификатор клавиша Control
            </summary>
        </member>
        <member name="F:MyCodeLibrary.GlobalHotkey.MOD_SHIFT">
            <summary>
            Модификатор клавиша Shift
            </summary>
        </member>
        <member name="F:MyCodeLibrary.GlobalHotkey.MOD_WIN">
            <summary>
            Модификатор клавиша Windows
            </summary>
        </member>
        <member name="F:MyCodeLibrary.GlobalHotkey.WM_HOTKEY">
            <summary>
            Идентификатор сообщения виндовс
            </summary>
        </member>
        <member name="F:MyCodeLibrary.GlobalHotkey.m_WindowHandle">
            <summary>
            Описатель окна
            </summary>
        </member>
        <member name="F:MyCodeLibrary.GlobalHotkey.m_HotkeyId">
            <summary>
            Идентификатор хоткея в сообщении для окна
            </summary>
        </member>
        <member name="M:MyCodeLibrary.GlobalHotkey.#ctor">
            <summary>
            Default constructor.
            Use Register() to register this new hotkey
            </summary>
        </member>
        <member name="M:MyCodeLibrary.GlobalHotkey.#ctor(System.Windows.Forms.Form,System.Int32,System.Int32,System.Windows.Forms.Keys)">
            <summary>
            Param constructor
            Throw Exception if hotkey registration fail.
            </summary>
            <param name="form">Current form object</param>
            <param name="hotkeyId">Identifier for new hotkey. Must be any value between 0 and 0xBFFF.</param>
            <param name="modifiers">Key modifier like MOD_CONTROL | MOD_WIN</param>
            <param name="key">Single virtual key code, like Keys.K</param>
        </member>
        <member name="M:MyCodeLibrary.GlobalHotkey.Register(System.Windows.Forms.Form,System.Int32,System.Int32,System.Windows.Forms.Keys)">
            <summary>
            Register global hotkey
            Return False if hotkey registration fail.
            </summary>
            <param name="form">Current form object</param>
            <param name="hotkeyId">Identifier for new hotkey. Must be any value between 0 and 0xBFFF.</param>
            <param name="modifiers">Key modifier like MOD_CONTROL | MOD_WIN</param>
            <param name="key">Single virtual key code, like Keys.K</param>
            <returns>Return False if hotkey registration fail.</returns>
        </member>
        <member name="M:MyCodeLibrary.GlobalHotkey.Unregister">
            <summary>
            Unregister current hotkey
            </summary>
            <returns>Returns false if hotkey releasing fail.</returns>
        </member>
        <member name="M:MyCodeLibrary.GlobalHotkey.ThisHotkey(System.Windows.Forms.Message)">
            <summary>
            Check that Message is current hotkey message
            </summary>
            <param name="msg">Window Message object</param>
            <returns>Returns True if this hotkey activated. Returns False otherwise/</returns>
        </member>
        <member name="M:MyCodeLibrary.GlobalHotkey.ThisHotkey(System.Windows.Forms.Message,MyCodeLibrary.GlobalHotkey)">
            <summary>
            Check that Message is current hotkey message
            </summary>
            <param name="msg">Window Message object</param>
            <param name="gh">Global hotkey object</param>
            <returns>Returns True if this hotkey activated. Returns False otherwise/</returns>
        </member>
        <member name="T:MyCodeLibrary.KeyboardLayouts">
            <summary>
            Функции управления раскладками клавиатуры
            </summary>
            <remarks>
            Для консольных приложений это не работает. Там надо переключать через комбинации клавиш.
            Переключается раскладка для текущего потока, а не для всего процесса.
            В GUI приложении обычно один (текущий) поток обслуживает ввод. Поэтому это там работает.
            В консольном приложении ввод обслуживается одним потоком, а приложение - другим. Поэтому там не работает.
            </remarks>
        </member>
        <member name="M:MyCodeLibrary.KeyboardLayouts.GetInputLanguageByName(System.String)">
            <summary>
            RT-Получить раскладку клавиатуры  по имени раскладки
            </summary>
            <param name="langname">
            Англоязычное название раскладки клавиатуры.
            English или eng, Russian или rus - используется регистронезависимое сравнение начальных символов
            </param>
            <returns>Возвращает найденный объект раскладки клавиатуры или null если ничего не найдено</returns>
        </member>
        <member name="M:MyCodeLibrary.KeyboardLayouts.SetKeyboardLayout(System.Windows.Forms.InputLanguage)">
            <summary>
            RT-Установить раскладку клавиатуры
            </summary>
            <param name="lang">Объект раскладки клавиатуры</param>
        </member>
        <member name="M:MyCodeLibrary.KeyboardLayouts.HasTwoMoreLanguages">
            <summary>
            RT-Вовзвращает TRUE если для приложения установлено более одной раскладки клавиатуры
            </summary>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.KeyboardLayouts.SetLayoutSimple(System.String)">
            <summary>
            RT-Установить раскладку клавиатуры по имени раскладки
            </summary>
            <param name="langname">
            Англоязычное название раскладки клавиатуры.
            English или eng, Russian или rus - используется регистронезависимое сравнение начальных символов
            </param>
        </member>
        <member name="M:MyCodeLibrary.KeyboardLayouts.GetLayouts">
            <summary>
            NT-Получить массив объектов раскладки клавиатуры для выбора в комбобоксе или меню.
            </summary>
            <returns></returns>
            <remarks>
            Тут проще было бы использовать InputLanguage.InstalledInputLanguages прямо,
            но у нас все как всегда. Поэтому передаем ее вызывающему коду без изменений.
            </remarks>
        </member>
        <member name="T:MyCodeLibrary.NamedMutex">
             <summary>
             Мутекс именованный, для синхронизации двух потоков или проверки приложения на запущенность.
             </summary>
            <example>
            static NamedMutex m_Mutex;
            static string m_MutexName = "MutexName1";
            
            static void Main(string[] args)
            {
                //check mutex exists
                m_Mutex = new NamedMutex();
                if (m_Mutex.Exists(m_MutexName) == true)
                {
                    Console.WriteLine("Other copy of server already exists. Move to Exit.");
                    return;
                }
                //else
                m_Mutex.Create(m_MutexName, true); 
                ... тут работаем далее
                m_Mutex.Release() - освобождаем мутекс для другого потока или в конце работы этого потока.
                нельзя оставлять мутекс не освобожденным.
                ... мутекс закрывается, когда срабатывает деструктор объекта ?
                тут нет деструктора лучше явно вызвать Close(), но в этом классе этого нет.
                Надо доделать класс!
             }
             </example>
        </member>
        <member name="F:MyCodeLibrary.NamedMutex.m_Mutex">
            <summary>
            Mutex internal object
            </summary>
        </member>
        <member name="M:MyCodeLibrary.NamedMutex.Create(System.String,System.Boolean)">
            <summary>
            NT-Create named mutex
            </summary>
            <param name="mutexName"></param>
            <param name="initiallyOwned"></param>
        </member>
        <member name="M:MyCodeLibrary.NamedMutex.Exists(System.String)">
            <summary>
            NT-Проверить существование мутекса по имени и получить его если существует.
            </summary>
            <returns>Возвращается true если мутекс существует, иначе false </returns>
        </member>
        <member name="M:MyCodeLibrary.NamedMutex.Own(System.Int32)">
            <summary>
            NT- Own mutex and wait for timeouts
            </summary>
            <param name="timeoutMs">
            The number of milliseconds to wait, or Timeout.Infinite (-1) to wait indefinitely. 
            If timeout is zero, the method does not block. It tests the state of the mutex and returns immediately. 
            </param>
            <returns>Returns True if mutex owned. False if timeout occurs.</returns>
        </member>
        <member name="M:MyCodeLibrary.NamedMutex.Test">
            <summary>
            NT- Test mutex state
            </summary>
            <returns>Returns True if mutex owned. False if timeout occurs.</returns>
        </member>
        <member name="M:MyCodeLibrary.NamedMutex.Release">
            <summary>
            NT-Release mutex
            </summary>
        </member>
        <member name="F:MyCodeLibrary.CProcessProcessor.m_docProcess">
            <summary>
            Процесс просмотра документа
            </summary>
        </member>
        <member name="M:MyCodeLibrary.CProcessProcessor.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MyCodeLibrary.CProcessProcessor.OpenDocument(System.String)">
            <summary>
            RT-запустить просмотр файла-документа
            </summary>
            <param name="filepath">Путь к файлу-документу: полный или относительно текущего каталога приложения.</param>
            <exception cref="T:System.IO.FileNotFoundException">Выбрасывает исключение, если указанный файл документа не найден.</exception>
        </member>
        <member name="M:MyCodeLibrary.CProcessProcessor.CloseDocument">
            <summary>
            NT-если просмотр документа уже запущен, закрыть его.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.CProcessProcessor.CloseApplicationByAppPath(System.String,System.Boolean,System.Int32)">
            <summary>
            Закрыть приложение
            </summary>
            <param name="appPath">Путь к исполняемому файлу приложения</param>
            <param name="kill">True - убить процесс, False - только попытаться закрыть главное окно приложения.</param>
            <param name="timeout">Таймаут ожидания завершения операции в миллисекундах. Используется дважды. По умолчанию = 5000</param>
            <returns>Возвращает результат операции: успех или неудача.</returns>
        </member>
        <member name="M:MyCodeLibrary.CProcessProcessor.CloseApplicationByMainWindowTitle(System.String,System.Boolean,System.Int32)">
            <summary>
            Закрыть приложение
            </summary>
            <param name="titleText">Путь к исполняемому файлу приложения</param>
            <param name="kill">True - убить процесс, False - только попытаться закрыть главное окно приложения.</param>
            <param name="timeout">Таймаут ожидания завершения операции в миллисекундах. Используется дважды. По умолчанию = 5000</param>
            <returns>Возвращает результат операции: успех или неудача.</returns>
        </member>
        <member name="M:MyCodeLibrary.CProcessProcessor.CloseProcess(System.Diagnostics.Process,System.Boolean,System.Int32)">
            <summary>
            Завершить процесс
            </summary>
            <param name="process">Объект экземпляра процесса</param>
            <param name="kill">True - убить процесс, False - только попытаться закрыть главное окно приложения.</param>
            <param name="timeout">Таймаут ожидания завершения операции в миллисекундах. Используется дважды. По умолчанию = 5000</param>
            <returns>Возвращает результат операции: успех или неудача.</returns>
        </member>
        <member name="M:MyCodeLibrary.CProcessProcessor.GetAllProcesses">
            <summary>
            Получить список всех процессов текущей машины
            </summary>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CProcessProcessor.GetProcessesByAppPath(System.String)">
            <summary>
            Получить список запущенных экземпляров указанного приложения
            </summary>
            <param name="appPath">Путь к исполняемому файлу приложения</param>
            <returns>Список запущенных экземпляров указанного приложения</returns>
        </member>
        <member name="M:MyCodeLibrary.CProcessProcessor.safeGetModuleFileName(System.Diagnostics.Process)">
            <summary>
            Безопасно получить путь к исполняемому файлу процесса
            </summary>
            <remarks>
            Некоторые процессы выбрасывают исключение "Недостаточно прав доступа" при попытке чтения имени модуля.
            Эта функция блокирует в себе эти исключения, возвращая null вместо имени модуля.
            </remarks>
            <param name="p">Объект процесса</param>
            <returns>Возвращает путь к исполняемому файлу процесса или null при ошибке доступа.</returns>
        </member>
        <member name="M:MyCodeLibrary.CProcessProcessor.GetProcessesByMainWindowTitle(System.String)">
            <summary>
            Получить список запущенных экземпляров указанного приложения
            </summary>
            <param name="appPath">Текст заголовка главного окна приложения</param>
            <returns>Список запущенных экземпляров указанного приложения</returns>
        </member>
        <member name="T:MyCodeLibrary.CProcessProcessor.Output">
            <summary>
            Output object that is returned after the CLI application has completed
            </summary>
        </member>
        <member name="M:MyCodeLibrary.CProcessProcessor.Output.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="P:MyCodeLibrary.CProcessProcessor.Output.Result">
            <summary>
            Returns the text result of the command.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.CProcessProcessor.Output.Error">
            <summary>
            Returns the error if an error occurred.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.CProcessProcessor.Output.ExitCode">
            <summary>
            Returns the exit code. Returns 0 if no error occurred.
            </summary>
        </member>
        <member name="P:MyCodeLibrary.CProcessProcessor.Output.Exception">
            <summary>
            Returns the exception if an exception occurred.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.CProcessProcessor.Run(System.Object)">
            <summary>
            NR-Runs a command prompt command.
            </summary>
            <param name="command"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CProcessProcessor.RunElevated(System.Object)">
            <summary>
            NR-Runs a command prompt command.
            </summary>
            <param name="command"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CProcessProcessor.Run(System.Object,System.Boolean)">
            <summary>
            NR-Runs a command prompt command.
            </summary>
            <param name="command"></param>
            <param name="returnOutput"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.CProcessProcessor.Run(System.Object,System.Boolean,System.Boolean)">
            <summary>
            NR-
            </summary>
            <param name="command"></param>
            <param name="returnOutput"></param>
            <param name="elevate"></param>
            <returns></returns>
        </member>
        <member name="T:MyCodeLibrary.QualifiedNameManager">
            <summary>
            Управляет квалифицированными именами.
            </summary>
            <remarks>
            Класс из проекта InventoryModuleManager - контроллера Хранилищ.
            Пример квалифицированного пути файла:
            Предмет.Радиодеталь.Транзистор/docs1/КТ315Б.pdf
            Предмет/pics1/picture.gif
            
            Здесь:
            Предмет.Радиодеталь.Транзистор - квалифицированное имя хранилища, 
            составленное из иерархии классов сущностей, 
            размещенных в Хранилище, от корня иерархии до класса сущности, представленной в Хранилище.
            То есть, в данном случае, в хранилище находятся сущности, относящиеся к классу Транзистор и его подклассам.
            И их строка типа должна начинаться с слова Транзистор.
            Классы разделены точкой. 
            
            После квалифицированного имени хранилища идет имя каталога. 
            Может быть только один каталог между именем файла и квалифицированным именем хранилища.
            Это имя определяет раздел хранилища: документ или изображение.
            Это же имя является именем файла архива, в котором находится файл. 
            Чтобы получить имя файла архива, надо добавить стандартное расширение архива.
            Это же имя используется для папки, которая находится в корне архива и в которой хранятся все помещаемые в архив файлы.
            Таким образом, при распаковке всех архивов вручную, относительный порядок в хранилище все еще сохраняется.
            Такая распаковка возможна, когда пользователю нужен доступ к файлам, а менеджер хранилища он не может использовать.
            В этом случае файлы архивов распаковываются в один каталог и оказываются в относительно упорядоченном виде.
             
            После имени каталога идет собственно имя файла в этом каталоге и его расширение.
            Все файлы внутри раздела документов либо внутри раздела изображений имеют уникальные имена.
            
            </remarks>
        </member>
        <member name="F:MyCodeLibrary.QualifiedNameManager.PathDelimiterString">
            <summary>
            Разделитель файлов и каталогов в пути
            </summary>
        </member>
        <member name="M:MyCodeLibrary.QualifiedNameManager.getStorageQName(System.String)">
            <summary>
            NT-Извлечь квалифицированное имя хранилища
            </summary>
            <param name="qualifiedName">Квалифицированный путь</param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.QualifiedNameManager.getFileQName(System.String)">
            <summary>
            NR-Извлечь путь к файлу в Хранилище
            </summary>
            <param name="qualifiedName"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.QualifiedNameManager.CombineForFile(System.String,System.String)">
            <summary>
            NT-Собрать квалифицированное имя файла
            </summary>
            <param name="storageQName">Квалифицированное имя хранилища</param>
            <param name="archpath">Путь файла внутри хранилища</param>
            <returns>Возвращает квалифицированное имя файла для использования вне хранилища</returns>
        </member>
        <member name="T:MyCodeLibrary.mySendKeys">
            <summary>
            Симулирует нажатия клавиш для текущего активного окна приложения.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.mySendKeys.SetInputWindow(System.IntPtr)">
            <summary>
            Сделать окно активным для приема нажатий клавиш
            </summary>
            <param name="hWnd">HWND окна</param>
        </member>
        <member name="M:MyCodeLibrary.mySendKeys.FindInputWindow(System.String,System.String)">
            <summary>
            Найти существующее главное окно приложения по его имени
            </summary>
            <param name="windowClassName">Название класса окна</param>
            <param name="windowCaptionText">Текст заголовка окна. Если null, любой текст заголовка окна подходит.</param>
            <returns>Возвращает HWND описатель окна, если окно найдено. Возвращает null, если окно не найдено; следует вызвать GetLastError() для получения кода ошибки.</returns>
        </member>
        <member name="M:MyCodeLibrary.mySendKeys.SendWait(System.IntPtr,System.String)">
            <summary>
            Отправить простой текст в указанное окно.
            См. описание класса System.Windows.Forms.SendKeys в МСДН.
            Но модификаторы %^+ здесь не работают, хотя строка с ними парсится правильно.
            </summary>
            <param name="hWnd">HWND окна</param>
            <param name="text">Строка текста</param>
        </member>
        <member name="M:MyCodeLibrary.mySendKeys.SendKeysWithModifiers(System.Windows.Forms.Keys[],System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Отправить последовательность клавиш с модификаторами в текущее активное окно
            </summary>
            <param name="ks">Массив нажимаемых клавиш</param>
            <param name="Ctrl">При нажатой клавише Control</param>
            <param name="Shift">При нажатой клавише Shift</param>
            <param name="Alt">При нажатой клавише Alt</param>
            <remarks>
            Если в процессе отправки событий в окно происходят некие помехи,
            то могут возникать странные эффекты в ОС. Например, на таскбаре не разворачиваются окна при клике, итп.
            Это потому что нажатые программно клавиши не были отпущены. 
            Их можно вручную покликать, это должно исправить проблему.
            Но все же это недостаточно надежный механизм управления приложением.
            Он нуждается в совершенствовании.
            </remarks>
        </member>
        <member name="M:MyCodeLibrary.mySendKeys.GetKeysArrayTab">
            <summary>
            Получить массив клавиш из одной клавиши TAB
            </summary>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.mySendKeys.GetKeysArrayEnter">
            <summary>
            Получить массив клавиш из одной клавиши ENTER
            </summary>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.mySendKeys.GetKeysArraySpace">
            <summary>
            Получить массив клавиш из одной клавиши SPACE
            </summary>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.ShellLinkOne.ShellLinksManager.GetShortcut(System.String)">
            <summary>
            NT-Прочитать файд ярлыка
            </summary>
            <param name="sFileName">Путь к файлу ярлыка</param>
            <returns>Возвращает объект ярлыка</returns>
            <remarks>//raise COMException if sFileName not a .lnk file</remarks>
        </member>
        <member name="F:MyCodeLibrary.ShellLinkTwo.CShortCut.SLGP_FLAGS.SLGP_SHORTPATH">
            <summary>Retrieves the standard short (8.3 format) file name</summary>
        </member>
        <member name="F:MyCodeLibrary.ShellLinkTwo.CShortCut.SLGP_FLAGS.SLGP_UNCPRIORITY">
            <summary>Retrieves the Universal Naming Convention (UNC) path name of the file</summary>
        </member>
        <member name="F:MyCodeLibrary.ShellLinkTwo.CShortCut.SLGP_FLAGS.SLGP_RAWPATH">
            <summary>Retrieves the raw path name. A raw path is something that might not exist and may include environment variables that need to be expanded</summary>
        </member>
        <member name="F:MyCodeLibrary.ShellLinkTwo.CShortCut.SLR_FLAGS.SLR_NO_UI">
            <summary>
            Do not display a dialog box if the link cannot be resolved. When SLR_NO_UI is set,
            the high-order word of fFlags can be set to a time-out value that specifies the
            maximum amount of time to be spent resolving the link. The function returns if the
            link cannot be resolved within the time-out duration. If the high-order word is set
            to zero, the time-out duration will be set to the default value of 3,000 milliseconds
            (3 seconds). To specify a value, set the high word of fFlags to the desired time-out
            duration, in milliseconds.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.ShellLinkTwo.CShortCut.SLR_FLAGS.SLR_ANY_MATCH">
            <summary>Obsolete and no longer used</summary>
        </member>
        <member name="F:MyCodeLibrary.ShellLinkTwo.CShortCut.SLR_FLAGS.SLR_UPDATE">
            <summary>If the link object has changed, update its path and list of identifiers.
            If SLR_UPDATE is set, you do not need to call IPersistFile::IsDirty to determine
            whether or not the link object has changed.</summary>
        </member>
        <member name="F:MyCodeLibrary.ShellLinkTwo.CShortCut.SLR_FLAGS.SLR_NOUPDATE">
            <summary>Do not update the link information</summary>
        </member>
        <member name="F:MyCodeLibrary.ShellLinkTwo.CShortCut.SLR_FLAGS.SLR_NOSEARCH">
            <summary>Do not execute the search heuristics</summary>
        </member>
        <member name="F:MyCodeLibrary.ShellLinkTwo.CShortCut.SLR_FLAGS.SLR_NOTRACK">
            <summary>Do not use distributed link tracking</summary>
        </member>
        <member name="F:MyCodeLibrary.ShellLinkTwo.CShortCut.SLR_FLAGS.SLR_NOLINKINFO">
            <summary>Disable distributed link tracking. By default, distributed link tracking tracks
            removable media across multiple devices based on the volume name. It also uses the
            Universal Naming Convention (UNC) path to track remote file systems whose drive letter
            has changed. Setting SLR_NOLINKINFO disables both types of tracking.</summary>
        </member>
        <member name="F:MyCodeLibrary.ShellLinkTwo.CShortCut.SLR_FLAGS.SLR_INVOKE_MSI">
            <summary>Call the Microsoft Windows Installer</summary>
        </member>
        <member name="T:MyCodeLibrary.ShellLinkTwo.CShortCut.IShellLinkW">
            <summary>The IShellLink interface allows Shell links to be created, modified, and resolved</summary>
        </member>
        <member name="M:MyCodeLibrary.ShellLinkTwo.CShortCut.IShellLinkW.GetPath(System.Text.StringBuilder,System.Int32,MyCodeLibrary.ShellLinkTwo.CShortCut.WIN32_FIND_DATAW@,MyCodeLibrary.ShellLinkTwo.CShortCut.SLGP_FLAGS)">
            <summary>Retrieves the path and file name of a Shell link object</summary>
        </member>
        <member name="M:MyCodeLibrary.ShellLinkTwo.CShortCut.IShellLinkW.GetIDList(System.IntPtr@)">
            <summary>Retrieves the list of item identifiers for a Shell link object</summary>
        </member>
        <member name="M:MyCodeLibrary.ShellLinkTwo.CShortCut.IShellLinkW.SetIDList(System.IntPtr)">
            <summary>Sets the pointer to an item identifier list (PIDL) for a Shell link object.</summary>
        </member>
        <member name="M:MyCodeLibrary.ShellLinkTwo.CShortCut.IShellLinkW.GetDescription(System.Text.StringBuilder,System.Int32)">
            <summary>Retrieves the description string for a Shell link object</summary>
        </member>
        <member name="M:MyCodeLibrary.ShellLinkTwo.CShortCut.IShellLinkW.SetDescription(System.String)">
            <summary>Sets the description for a Shell link object. The description can be any application-defined string</summary>
        </member>
        <member name="M:MyCodeLibrary.ShellLinkTwo.CShortCut.IShellLinkW.GetWorkingDirectory(System.Text.StringBuilder,System.Int32)">
            <summary>Retrieves the name of the working directory for a Shell link object</summary>
        </member>
        <member name="M:MyCodeLibrary.ShellLinkTwo.CShortCut.IShellLinkW.SetWorkingDirectory(System.String)">
            <summary>Sets the name of the working directory for a Shell link object</summary>
        </member>
        <member name="M:MyCodeLibrary.ShellLinkTwo.CShortCut.IShellLinkW.GetArguments(System.Text.StringBuilder,System.Int32)">
            <summary>Retrieves the command-line arguments associated with a Shell link object</summary>
        </member>
        <member name="M:MyCodeLibrary.ShellLinkTwo.CShortCut.IShellLinkW.SetArguments(System.String)">
            <summary>Sets the command-line arguments for a Shell link object</summary>
        </member>
        <member name="M:MyCodeLibrary.ShellLinkTwo.CShortCut.IShellLinkW.GetHotkey(System.Int16@)">
            <summary>Retrieves the hot key for a Shell link object</summary>
        </member>
        <member name="M:MyCodeLibrary.ShellLinkTwo.CShortCut.IShellLinkW.SetHotkey(System.Int16)">
            <summary>Sets a hot key for a Shell link object</summary>
        </member>
        <member name="M:MyCodeLibrary.ShellLinkTwo.CShortCut.IShellLinkW.GetShowCmd(System.Int32@)">
            <summary>Retrieves the show command for a Shell link object</summary>
        </member>
        <member name="M:MyCodeLibrary.ShellLinkTwo.CShortCut.IShellLinkW.SetShowCmd(System.Int32)">
            <summary>Sets the show command for a Shell link object. The show command sets the initial show state of the window.</summary>
        </member>
        <member name="M:MyCodeLibrary.ShellLinkTwo.CShortCut.IShellLinkW.GetIconLocation(System.Text.StringBuilder,System.Int32,System.Int32@)">
            <summary>Retrieves the location (path and index) of the icon for a Shell link object</summary>
        </member>
        <member name="M:MyCodeLibrary.ShellLinkTwo.CShortCut.IShellLinkW.SetIconLocation(System.String,System.Int32)">
            <summary>Sets the location (path and index) of the icon for a Shell link object</summary>
        </member>
        <member name="M:MyCodeLibrary.ShellLinkTwo.CShortCut.IShellLinkW.SetRelativePath(System.String,System.Int32)">
            <summary>Sets the relative path to the Shell link object</summary>
        </member>
        <member name="M:MyCodeLibrary.ShellLinkTwo.CShortCut.IShellLinkW.Resolve(System.IntPtr,MyCodeLibrary.ShellLinkTwo.CShortCut.SLR_FLAGS)">
            <summary>Attempts to find the target of a Shell link, even if it has been moved or renamed</summary>
        </member>
        <member name="M:MyCodeLibrary.ShellLinkTwo.CShortCut.IShellLinkW.SetPath(System.String)">
            <summary>Sets the path and file name of a Shell link object</summary>
        </member>
        <member name="M:MyCodeLibrary.ShellLinkTwo.CShortCut.ResolveShortcut(System.String)">
            <summary>
            Извлекает путь из ярлыка. Возвращает пустую строку если файл не является ярлыком
            </summary>
            <param name="filename">Путь к файлу ярлыка</param>
            <returns>Возвращает путь к файлу цели ярлыка, или пустую строку если файл не является ярлыком</returns>
        </member>
        <member name="T:MyCodeLibrary.SingleInstance">
            <summary>
            NFT-Контролирует единственный экземпляр приложения в операционной системе
            TODO: Я не уверен, что этот класс будет стабильно работать для пользователя, у которого нет прав администратора.
            Это из-за именного мутекса - яхз, что там с правами пользователя. Нет сейчас возможности тестировать под разными пользователями. 
            </summary>
            <example>
            Этот код должен располагаться в начале приложения, еще до инициализации формы.
            Удобно поместить его в файле Program.cs сразу в начале Main()
            SingleInstance si = SingleInstance.Create("Meraman.Test");
            if (si == null)
            {
                MessageBox.Show("Not single instance", "Check");
                return;
            }
            //else work next code
            </example>
        </member>
        <member name="F:MyCodeLibrary.SingleInstance.m_uid">
            <summary>
            Уникальный идентификатор для приложения
            </summary>
        </member>
        <member name="P:MyCodeLibrary.SingleInstance.Uid">
            <summary>
            Уникальный идентификатор для приложения
            </summary>
        </member>
        <member name="F:MyCodeLibrary.SingleInstance.m_Mutex">
            <summary>
            Mutex internal object
            </summary>
        </member>
        <member name="M:MyCodeLibrary.SingleInstance.#ctor(System.String)">
            <summary>
            NT-Конструктор
            </summary>
            <param name="uid">Уникальный идентификатор для приложения</param>
        </member>
        <member name="M:MyCodeLibrary.SingleInstance.Finalize">
            <summary>
            NR-Деструктор
            </summary>
            <remarks>
            Срабатывает, когда объект уничтожается. 
            Благодаря ему, не надо специально вызывать освобождение мутекса в основном коде программы.
            </remarks>
        </member>
        <member name="M:MyCodeLibrary.SingleInstance.Create(System.String)">
            <summary>
            NT-Единственная функция проверки единственности 
            </summary>
            <param name="uid">Уникальный идентификатор для приложения, как имя мутекса</param>
            <returns>Если мутекс создан успешно, то возвращается ссылка на объект.
            Если мутекс уже существует или не может быть создан, возвращается null.
            Тогда приложение нужно закрыть, так как и мутекс не создан, и другая копия уже, вероятно, запущена.
            </returns>
        </member>
        <member name="M:MyCodeLibrary.SingleInstance.Exists(System.String)">
            <summary>
            NT-Проверить существование мутекса по имени и получить его если существует.
            </summary>
            <returns>Возвращается true если мутекс существует, иначе false </returns>
        </member>
        <member name="M:MyCodeLibrary.SingleInstance.ToString">
            <summary>
            NT-
            </summary>
            <returns></returns>
        </member>
        <member name="T:MyCodeLibrary.myVersion">
            <summary>
            NT-Версия программы Оператор и ее частей
            </summary>
        </member>
        <member name="F:MyCodeLibrary.myVersion.m_MainVersion">
            <summary>
            Номер версии
            </summary>
        </member>
        <member name="P:MyCodeLibrary.myVersion.MainVersion">
            <summary>
            Номер версии
            </summary>
        </member>
        <member name="F:MyCodeLibrary.myVersion.m_SubVersion">
            <summary>
            Номер подверсии
            </summary>
        </member>
        <member name="P:MyCodeLibrary.myVersion.SubVersion">
            <summary>
            Номер подверсии
            </summary>
        </member>
        <member name="F:MyCodeLibrary.myVersion.m_PatchNumber">
            <summary>
            Номер исправления
            </summary>
        </member>
        <member name="P:MyCodeLibrary.myVersion.PatchNumber">
            <summary>
            Номер исправления
            </summary>
        </member>
        <member name="F:MyCodeLibrary.myVersion.m_BuildNumber">
            <summary>
            Номер сборки
            </summary>
        </member>
        <member name="P:MyCodeLibrary.myVersion.BuildNumber">
            <summary>
            Номер сборки
            </summary>
        </member>
        <member name="M:MyCodeLibrary.myVersion.#ctor">
            <summary>
            NT- Default constructor
            </summary>
        </member>
        <member name="M:MyCodeLibrary.myVersion.#ctor(System.Version)">
            <summary>
            NT-Конструктор из объекта версии
            </summary>
        </member>
        <member name="M:MyCodeLibrary.myVersion.#ctor(System.String)">
            <summary>
            NT-Конструктор из строки версии
            </summary>
            <param name="versionString">Строка версии, только цифры. Пример: 1.0.24.0546</param>
        </member>
        <member name="M:MyCodeLibrary.myVersion.IsEquivalentVersion(MyCodeLibrary.myVersion)">
            <summary>
            NT-Можно ли указанную версию считать эквивалентной текущей версии.
            </summary>
            <param name="ver"></param>
            <remarks>
            Сравниваются поля версии и подверсии. Номер патча и билда игнорируются.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.myVersion.IsCompatibleVersion(MyCodeLibrary.myVersion)">
            <summary>
            NT-Можно ли указанную версию считать допустимой для работы с ней.
            </summary>
            <param name="ver"></param>
            <remarks>
            Сравниваются поля версии и подверсии. Номер патча и билда игнорируются.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.myVersion.Parse(System.String)">
            <summary>
            NT-Парсить строку версии
            </summary>
            <param name="versionString"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.myVersion.ToString">
            <summary>
            NT-
            </summary>
            <returns></returns>
        </member>
        <member name="T:MyCodeLibrary.UsingCounter">
            <summary>
            Это класс для подсчета статистики использования функций приложения. Например, вызовов пунктов меню.
            Это позволяет выявить часто или редко используемые функции приложения и соответственно управлять видимостью пунктов меню.
            И отсылать статистику разработчику, чтобы выявить неиспользуемые функции.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.UsingCounter.m_CounterFileName">
            <summary>
            Путь к файлу, хранящему счетчики. 
            Этот файл должен располагаться в каталоге, где пользователь имеет права на запись.
            Типично в User/LocalSettings/AppName/...
            Не в каталоге приложения в ProgramFiles.
            </summary>
        </member>
        <member name="F:MyCodeLibrary.UsingCounter.m_Counters">
            <summary>
            Словарь счетчиков и их имен-тегов
            </summary>
        </member>
        <member name="M:MyCodeLibrary.UsingCounter.#ctor(System.String)">
            <summary>
            Конструктор класса
            </summary>
            <param name="counterFileName">Путь к файлу, хранящему счетчики. 
            Этот файл должен располагаться в каталоге, где пользователь имеет права на запись. 
            Типично в User/LocalSettings/AppName/...
            Не в каталоге приложения в ProgramFiles.
            </param>
        </member>
        <member name="P:MyCodeLibrary.UsingCounter.Counters">
            <summary>
            Ссылка на словарь счетчиков
            </summary>
        </member>
        <member name="M:MyCodeLibrary.UsingCounter.Load">
            <summary>
            Загрузить статистику из файла статистики.
            </summary>
        </member>
        <member name="M:MyCodeLibrary.UsingCounter.Store">
            <summary>
            Сохранить статистику в файл статистики
            </summary>
        </member>
        <member name="M:MyCodeLibrary.UsingCounter.Use(System.String)">
            <summary>
            Добавить одно использование функции
            </summary>
            <param name="tagname">
            Имя тега - аббревиатура функции, именующая счетчик вызовов этой функции приложения.
            Имя тега не должно содержать пробелы, переносы строк и знак =
            Имя тега не должно быть пустой строкой
            </param>
            <exception cref="T:System.ArgumentException">Имя тега не должно быть пустым или = null</exception>
        </member>
        <member name="M:MyCodeLibrary.UsingCounter.Clear">
            <summary>
            Очистка словаря счетчиков
            </summary>
        </member>
        <member name="T:MyCodeLibrary.Свалка">
            <summary>
            NR-Свалка функций которые надо куда-то пристроить
            </summary>
        </member>
        <member name="M:MyCodeLibrary.Свалка.ByteStringToObject(System.String)">
            <summary>
            Breaks a byte string value into a object
            </summary>
            <param name="bytes"></param>
            <returns></returns>
        </member>
        <member name="M:MyCodeLibrary.Свалка.ObjectToByteString(System.Object)">
            <summary>
            Converts an object into a byte string
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
    </members>
</doc>
