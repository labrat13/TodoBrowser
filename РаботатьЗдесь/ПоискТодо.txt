Цель: собрать из проекта все задачи, просмотреть, чтобы оценить и отметить их очередность, и вывести в один список для копирования в общий файл задач проекта.

++ Задача 
- извлечь из указанной папки проекта все тодо,
- превратить их в объекты с указанием файла-источника задачи, таймштампа извлечения, содержания задачи, ияхзчтоеще,
- вывести в файл XML как список задач,
- вывести в окно приложения для выбора и просмотра и операций с ними.

++ Замечания
Тупой поиск Надо выглядит неподходящим.

1. Для более четких результатов надо искать задачи, размеченные тегами.
Но для этого надо их размечать, вручную, сразу при написании текстов.
А поиск просто по слову Надо выведет кучу не-задач, которые и в задачи не могут быть преобразованы.
Как вот этот текст - тут Надо обозначает не задачу, а формулировку потребности в ходе рассуждения.

Но иногда это именно задачи. Вот как отличать задачи от недо-задач?


2. Надо все предложение выводить в результатах поиска. От точки до точки.

3. Надо выводить каждый случай в собственном объекте - разделе, а не в общий файл текста без разделения.
   Сейчас не поймешь, где случай начинается и где кончается.
 - То есть, надо форматировать выходной файл. Что-то вроде ХМЛ?
 - Тут явно нужен гуи для ручного отбора и разметки надо-задач пользователем.
 - может, как-нибудь нейросеть удастся обучить выявлять из текстов надо-задачи? 
   - для этого сначала пользователь должен их разметить и обучить нейросеть.
   - для этого надо словоформы перевести в классы слов. 

++ Идеи по разработке
- ТОДО: нужен механизм извлечения задач из текстовых файлов по тегу ТОДО: TODO: todo: DONE: done: QUESTION: question: Вопрос: Сделано:	
	- надо иметь возможность редактировать эти наборы тегов, а не зашивать их в код поиска задач.
	- 1 проблема: как указать/хранить местонахождение задачи для пользователя? 
	    - Как файл и позицию.
	- 2 проблема: Как определить конец текста задачи?
		- это перевод строки либо точка и пробел либо достижение максимальной длины в 256 символов.
	- 3 проблема: кодировки текстовых файлов - разные.
		- где-то у меня есть код, определяющий кодировку текстового файла, но он не готов для использования.
- где-то есть у меня проект на эту тему.
  Там  проблемой было - контекст задачи из текста задачи совершенно не понятен. Надо лезть в исходный текст и разбираться.
    - это надо просто правильно описывать задачу, и все будет хорошо.
    В википаде подобный механизм вполне работает - там есть и сбор задач, и переход к выбранной задаче, и сорировка задач по классам - все там опробовано, реализовано. Только исполнять их не хочется.
		- но в википаде экспорт задач нельзя в сторонние приложения делать - вот это плохо.
		
- строение задачи:
	1. текст тега задачи (TODO: todo: Сделать: DONE: done: Сделано: QUESTION: question: Вопрос: 
	2. текст формулы задачи
	Пример: - ТОДО: нужен механизм извлечения задач из текстовых файлов
- классы задач, классы тегов задач
  - Сделать (todo тодо надо ) - собственно постановка задачи
  - Сделано ( done )          - пометка задачи выполненной
  - Вопрос  (изучить question ) - не задача, так как нет конкретики. Надо изучить тему, найти ответ на вопрос.
  - ...  вроде еще должны быть классы задач, но я что-то ничего не вспомню сейчас.
- механизм извлечения задач:
	- вход: 
		- путь к каталогу для поиска задач в файлах и вложенных папках внутри него.
		- список расширений файлов, в которых искать задачи
		- список тегов задач
	- выход:
		- список объектов найденных задач.
			- или словарь по тегам задач?
			- состав объекта найденной задачи (в старой документации - тодо-задача)
				- уникальный идентификатор задачи, ID
				- текст тега как класс задачи
				- текст формулы задачи
				- таймштамп извлечения из текста
				- путь к файлу, содержащему задачу
				- позиция начала текста тега - начала тела задачи - в файле 
				- позиция конца формулы задачи - конца тела задачи - в файле. 
- использование механизма извлечения задач:
	- нужно собрать задачи по проектам и вывести на экран пользователю их список
		- запускаем механизм для выбранного либо каждого проекта, указывая корневой каталог проекта.
		- получаем список тодо-задач, сортируем его, выводим пользователю в удобном виде.
		
++ Примеры 
Парсер тодо из википада:
из файла wikidPadParser.py:

//функция Создать регекс - возвращает набор ключ-значение
def buildRegex(regex, name=None, hideOnEmpty=False):
    if name is None:
        element = Regex(regex, RE_FLAGS)
    else:
        element = Regex(regex, RE_FLAGS).setResultsName(name).setName(name)
    
    if hideOnEmpty:
        element.setParseAction(actionHideOnEmpty)
        
    return element




# -------------------- Todo-Entry --------------------
//функция-обработчик тодо-предложения
def actionTodoEntry(s, l, st, t):
    t.key = t.findFlatByName("key").getString() //извлечь из тодо-итема ключ как строку
    t.keyComponents = t.key.split(u".")//разбить тодо-тег на массив подтегов
    t.delimiter = t.findFlatByName("todoDelimiter").getString()//разделитель тодо как строка
    t.valueNode = t.findFlatByName("value")//значение тодо-итема
    t.todos = [(t.key, t.valueNode)]//хз что это


//это регекс выделения тодо-тегов с подтегами через точку
//тут надо чтобы не было букв и цифр перед todo тегом.
//а вот скобки и тире - допустимы
//протестировано на регекс тестере - ловит теги без двоеточия, возвращает позицию начала каждого найденного тега и его длину до :
todoKey = buildRegex(ur"\b(?:todo|done|wait|action|track|issue|question|project)(?:\.[^:\s]+)?", "key")
# todoKey = todoKey.setParseStartAction(preActCheckNothingLeft)
//вот этого бы и достаточно - позиция начала тодо-задачи есть, 
//  надо еще найти позицию ближайшего конца, и все скопировать в объект тодо-задачи.
//а как потом находить эту (задачу) позицию задачи в файле, чтобы открывать и показывать пользователю - яхз пока что.
//  Но сейчас задача - из указанного файла извлечь тодо-задачи и их позиции. А все прочее - потом как-нибудь.

//конец тодо: символы \n | ? ! .
//но неправильный - еще должен быть пробел после ?!.
//регекс этот неправильный - только перенос строки находит везде.
todoEnd = buildRegex(ur"\n|\||(?!.)")

todoEntry = todoKey + buildRegex(ur":", "todoDelimiter") + todoContent + \
        Optional(buildRegex(ur"\|"))

todoEntry = todoEntry.setResultsNameNoCopy("todoEntry")\
        .setParseAction(actionTodoEntry)
		
//регекс конца строки
stringEnd = buildRegex(ur"(?!.)", "stringEnd")
		
# Only for LanguageHelper.parseTodoEntry()
todoAsWhole = todoEntry + stringEnd


    @staticmethod
    def parseTodoValue(todoValue, wikiDocument=None):
        """
        Parse a todo value (right of the colon) and return the node or
        return None if value couldn't be parsed
        """
        baseDict = _buildBaseDict(wikiDocument=wikiDocument)
        try:
            t = todoContent.parseString(todoValue, parseAll=True,
                    baseDict=baseDict)
            return t[0]
        except:
            return None


    @staticmethod
    def parseTodoEntry(entry, wikiDocument=None):
        """
        Parse a complete todo entry (without end-token) and return the node or
        return None if value couldn't be parsed
        """
        baseDict = _buildBaseDict(wikiDocument=wikiDocument)
        try:
            t = todoAsWhole.parseString(entry, parseAll=True,
                    baseDict=baseDict)
            return t[0]
        except:
            traceback.print_exc()
            return None
-----------------------
			
	